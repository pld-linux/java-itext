### Eclipse Workspace Patch 1.0
#P iText-2.1.7
Index: src/core/com/lowagie/text/rtf/RtfTableCell.java
===================================================================
--- src/core/com/lowagie/text/rtf/RtfTableCell.java	(revision 0)
+++ src/core/com/lowagie/text/rtf/RtfTableCell.java	(revision 0)
@@ -0,0 +1,392 @@
+/*
+ * The contents of this file are subject to the Mozilla Public License Version 1.1
+ * (the "License"); you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the License.
+ *
+ * The Original Code is 'iText, a free JAVA-PDF library'.
+ *
+ * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
+ * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
+ * All Rights Reserved.
+ * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
+ * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
+ *
+ * Contributor(s): all the names of the contributors are added in the source code
+ * where applicable.
+ *
+ * Alternatively, the contents of this file may be used under the terms of the
+ * LGPL license (the "GNU LIBRARY GENERAL PUBLIC LICENSE"), in which case the
+ * provisions of LGPL are applicable instead of those above.  If you wish to
+ * allow use of your version of this file only under the terms of the LGPL
+ * License and not to allow others to use your version of this file under
+ * the MPL, indicate your decision by deleting the provisions above and
+ * replace them with the notice and other provisions required by the LGPL.
+ * If you do not delete the provisions above, a recipient may use your version
+ * of this file under either the MPL or the GNU LIBRARY GENERAL PUBLIC LICENSE.
+ *
+ * This library is free software; you can redistribute it and/or modify it
+ * under the terms of the MPL as stated above or under the terms of the GNU
+ * Library General Public License as published by the Free Software Foundation;
+ * either version 2 of the License, or any later version.
+ *
+ * This library is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU Library general Public License for more
+ * details.
+ *
+ * If you didn't download this code from the following link, you should check if
+ * you aren't using an obsolete version:
+ * http://www.lowagie.com/iText/
+ */
+
+package com.lowagie.text.rtf;
+
+import com.lowagie.text.Cell;
+import com.lowagie.text.Element;
+import com.lowagie.text.BadElementException;
+
+import java.util.Properties;
+
+/**
+ * A <code>Cell</code> with extended style attributes
+ *
+ * ONLY FOR USE WITH THE RtfWriter NOT with the RtfWriter2.
+ * @deprecated Please move to the RtfWriter2 and associated classes. com.lowagie.text.rtf.table.RtfCell replaces the functionality of this class.
+ */
+public class RtfTableCell extends Cell
+{
+    /* Table border styles */
+
+    /** Table border solid */
+    public static final int BORDER_UNDEFINED = 0;
+
+    /** Table border solid */
+    public static final int BORDER_SINGLE = 1;
+
+    /** Table border double thickness */
+    public static final int BORDER_DOUBLE_THICK = 2;
+
+    /** Table border shadowed */
+    public static final int BORDER_SHADOWED = 3;
+
+    /** Table border dotted */
+    public static final int BORDER_DOTTED = 4;
+
+    /** Table border dashed */
+    public static final int BORDER_DASHED = 5;
+
+    /** Table border hairline */
+    public static final int BORDER_HAIRLINE = 6;
+
+    /** Table border double line */
+    public static final int BORDER_DOUBLE = 7;
+
+    /** Table border dot dash line */
+    public static final int BORDER_DOT_DASH = 8;
+
+    /** Table border dot dot dash line */
+    public static final int BORDER_DOT_DOT_DASH = 9;
+
+    /** Table border triple line */
+    public static final int BORDER_TRIPLE = 10;
+
+    /** Table border line */
+    public static final int BORDER_THICK_THIN = 11;
+
+    /** Table border line */
+    public static final int BORDER_THIN_THICK = 12;
+
+    /** Table border line */
+    public static final int BORDER_THIN_THICK_THIN = 13;
+
+    /** Table border line */
+    public static final int BORDER_THICK_THIN_MED = 14;
+
+    /** Table border line */
+    public static final int BORDER_THIN_THICK_MED = 15;
+
+    /** Table border line */
+    public static final int BORDER_THIN_THICK_THIN_MED = 16;
+
+    /** Table border line */
+    public static final int BORDER_THICK_THIN_LARGE = 17;
+
+    /** Table border line */
+    public static final int BORDER_THIN_THICK_LARGE = 18;
+
+    /** Table border line */
+    public static final int BORDER_THIN_THICK_THIN_LARGE = 19;
+
+    /** Table border line */
+    public static final int BORDER_WAVY = 20;
+
+    /** Table border line */
+    public static final int BORDER_DOUBLE_WAVY = 21;
+
+    /** Table border line */
+    public static final int BORDER_STRIPED = 22;
+
+    /** Table border line */
+    public static final int BORDER_EMBOSS = 23;
+
+    /** Table border line */
+    public static final int BORDER_ENGRAVE = 24;
+
+    /* Instance variables */
+    private float topBorderWidth;
+    private float leftBorderWidth;
+    private float rightBorderWidth;
+    private float bottomBorderWidth;
+    private int topBorderStyle = 1;
+    private int leftBorderStyle = 1;
+    private int rightBorderStyle = 1;
+    private int bottomBorderStyle = 1;
+
+/**
+ * Constructs an empty <CODE>Cell</CODE> (for internal use only).
+ *
+ * @param   dummy   a dummy value
+ */
+
+    public RtfTableCell(boolean dummy) {
+        super(dummy);
+    }
+
+/**
+ * Constructs a <CODE>Cell</CODE> with a certain <CODE>Element</CODE>.
+ * <P>
+ * if the element is a <CODE>ListItem</CODE>, <CODE>Row</CODE> or
+ * <CODE>Cell</CODE>, an exception will be thrown.
+ *
+ * @param	element		the element
+ * @throws	BadElementException when the creator was called with a <CODE>ListItem</CODE>, <CODE>Row</CODE> or <CODE>Cell</CODE>
+ */
+    public RtfTableCell(Element element) throws BadElementException {
+        super(element);
+    }
+
+/**
+ * Constructs a <CODE>Cell</CODE> with a certain content.
+ * <P>
+ * The <CODE>String</CODE> will be converted into a <CODE>Paragraph</CODE>.
+ *
+ * @param	content		a <CODE>String</CODE>
+ */
+    public RtfTableCell(String content) {
+        super(content);
+    }
+
+///**
+// * Returns a <CODE>Cell</CODE> that has been constructed taking in account
+// * the value of some <VAR>attributes</VAR>.
+// *
+// * @param	attributes		Some attributes
+// */
+//
+//    public RtfTableCell(Properties attributes) {
+//        super(attributes);
+//    }
+
+    /**
+     * Set all four borders to <code>f</code> width
+     *
+     * @param f the desired width
+     */
+    public void setBorderWidth(float f) {
+        super.setBorderWidth(f);
+        topBorderWidth = f;
+        leftBorderWidth = f;
+        rightBorderWidth = f;
+        bottomBorderWidth = f;
+    }
+
+    /**
+     * Set the top border to <code>f</code> width
+     *
+     * @param f the desired width
+     */
+    public void setTopBorderWidth(float f) {
+        topBorderWidth = f;
+    }
+
+    /**
+     * Get the top border width
+     * @return a width
+     */
+    public float topBorderWidth() {
+        return topBorderWidth;
+    }
+
+    /**
+     * Set the left border to <code>f</code> width
+     *
+     * @param f the desired width
+     */
+    public void setLeftBorderWidth(float f) {
+        leftBorderWidth = f;
+    }
+
+    /**
+     * Get the left border width
+     * @return a width
+     */
+    public float leftBorderWidth() {
+        return leftBorderWidth;
+    }
+
+    /**
+     * Set the right border to <code>f</code> width
+     *
+     * @param f the desired width
+     */
+    public void setRightBorderWidth(float f) {
+        rightBorderWidth = f;
+    }
+
+    /**
+     * Get the right border width
+     * @return a width
+     */
+    public float rightBorderWidth() {
+        return rightBorderWidth;
+    }
+
+    /**
+     * Set the bottom border to <code>f</code> width
+     *
+     * @param f the desired width
+     */
+    public void setBottomBorderWidth(float f) {
+        bottomBorderWidth = f;
+    }
+
+    /**
+     * Get the bottom border width
+     * @return a width
+     */
+    public float bottomBorderWidth() {
+        return bottomBorderWidth;
+    }
+
+    /**
+     * Set all four borders to style defined by <code>style</code>
+     *
+     * @param style the desired style
+     */
+    public void setBorderStyle(int style) {
+        topBorderStyle = style;
+        leftBorderStyle = style;
+        rightBorderStyle = style;
+        bottomBorderStyle = style;
+    }
+
+    /**
+     * Set the top border to style defined by <code>style</code>
+     *
+     * @param style the desired style
+     */
+    public void setTopBorderStyle(int style) {
+        topBorderStyle = style;
+    }
+
+    /**
+     * Get the top border style
+     * @return a style value
+     */
+    public int topBorderStyle() {
+        return topBorderStyle;
+    }
+
+    /**
+     * Set the left border to style defined by <code>style</code>
+     *
+     * @param style the desired style
+     */
+    public void setLeftBorderStyle(int style) {
+        leftBorderStyle = style;
+    }
+
+    /**
+     * Get the left border style
+     * @return a style value
+     */
+    public int leftBorderStyle() {
+        return leftBorderStyle;
+    }
+
+    /**
+     * Set the right border to style defined by <code>style</code>
+     *
+     * @param style the desired style
+     */
+    public void setRightBorderStyle(int style) {
+        rightBorderStyle = style;
+    }
+
+    /**
+     * Get the right border style
+     * @return a style value
+     */
+    public int rightBorderStyle() {
+        return rightBorderStyle;
+    }
+
+    /**
+     * Set the bottom border to style defined by <code>style</code>
+     *
+     * @param style the desired style
+     */
+    public void setBottomBorderStyle(int style) {
+        bottomBorderStyle = style;
+    }
+
+    /**
+     * Get the bottom border style
+     * @return a style value
+     */
+    public int bottomBorderStyle() {
+        return bottomBorderStyle;
+    }
+
+    /**
+     * Get the RTF control word for <code>style</code>
+     * @param style a style value
+     * @return a byte array corresponding with a style control word
+     */
+    protected static byte[] getStyleControlWord(int style) {
+        switch(style)
+        {
+            case BORDER_UNDEFINED				: return "brdrs".getBytes();
+            case BORDER_SINGLE 					: return "brdrs".getBytes();
+            case BORDER_DOUBLE_THICK	 		: return "brdrth".getBytes();
+            case BORDER_SHADOWED 				: return "brdrsh".getBytes();
+            case BORDER_DOTTED   				: return "brdrdot".getBytes();
+            case BORDER_DASHED   				: return "brdrdash".getBytes();
+            case BORDER_HAIRLINE   				: return "brdrhair".getBytes();
+            case BORDER_DOUBLE 		  			: return "brdrdb".getBytes();
+            case BORDER_DOT_DASH   				: return "brdrdashd".getBytes();
+            case BORDER_DOT_DOT_DASH			: return "brdrdashdd".getBytes();
+            case BORDER_TRIPLE					: return "brdrtriple".getBytes();
+            case BORDER_THICK_THIN				: return "brdrtnthsg".getBytes();
+            case BORDER_THIN_THICK				: return "brdrthtnsg".getBytes();
+            case BORDER_THIN_THICK_THIN			: return "brdrtnthtnsg".getBytes();
+            case BORDER_THICK_THIN_MED			: return "brdrtnthmg".getBytes();
+            case BORDER_THIN_THICK_MED			: return "brdrthtnmg".getBytes();
+            case BORDER_THIN_THICK_THIN_MED		: return "brdrtnthtnmg".getBytes();
+            case BORDER_THICK_THIN_LARGE		: return "brdrtnthlg".getBytes();
+            case BORDER_THIN_THICK_LARGE		: return "brdrthtnlg".getBytes();
+            case BORDER_THIN_THICK_THIN_LARGE	: return "brdrtnthtnlg".getBytes();
+            case BORDER_WAVY					: return "brdrwavy".getBytes();
+            case BORDER_DOUBLE_WAVY				: return "brdrwavydb".getBytes();
+            case BORDER_STRIPED					: return "brdrdashdotstr".getBytes();
+            case BORDER_EMBOSS					: return "brdremboss".getBytes();
+            case BORDER_ENGRAVE					: return "brdrengrave".getBytes();
+        }
+
+        return "brdrs".getBytes();
+    }
+}
Index: src/core/com/lowagie/text/rtf/RtfTable.java
===================================================================
--- src/core/com/lowagie/text/rtf/RtfTable.java	(revision 0)
+++ src/core/com/lowagie/text/rtf/RtfTable.java	(revision 0)
@@ -0,0 +1,201 @@
+/**
+ * $Id$
+ * $Name$
+ *
+ * Copyright 2001, 2002 by Mark Hall
+ *
+ * The contents of this file are subject to the Mozilla Public License Version 1.1
+ * (the "License"); you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the License.
+ *
+ * The Original Code is 'iText, a free JAVA-PDF library'.
+ *
+ * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
+ * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
+ * All Rights Reserved.
+ * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
+ * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
+ *
+ * Contributor(s): all the names of the contributors are added in the source code
+ * where applicable.
+ *
+ * Alternatively, the contents of this file may be used under the terms of the
+ * LGPL license (the ?GNU LIBRARY GENERAL PUBLIC LICENSE?), in which case the
+ * provisions of LGPL are applicable instead of those above.  If you wish to
+ * allow use of your version of this file only under the terms of the LGPL
+ * License and not to allow others to use your version of this file under
+ * the MPL, indicate your decision by deleting the provisions above and
+ * replace them with the notice and other provisions required by the LGPL.
+ * If you do not delete the provisions above, a recipient may use your version
+ * of this file under either the MPL or the GNU LIBRARY GENERAL PUBLIC LICENSE.
+ *
+ * This library is free software; you can redistribute it and/or modify it
+ * under the terms of the MPL as stated above or under the terms of the GNU
+ * Library General Public License as published by the Free Software Foundation;
+ * either version 2 of the License, or any later version.
+ *
+ * This library is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU Library general Public License for more
+ * details.
+ *
+ * If you didn't download this code from the following link, you should check if
+ * you aren't using an obsolete version:
+ * http://www.lowagie.com/iText/
+ */
+
+package com.lowagie.text.rtf;
+
+import com.lowagie.text.*;
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.io.*;
+
+/**
+ * A Helper Class for the <CODE>RtfWriter</CODE>.
+ * <P>
+ * Do not use it directly, except if you want to write a <CODE>DocumentListener</CODE> for Rtf
+ *
+ * ONLY FOR USE WITH THE RtfWriter NOT with the RtfWriter2.
+ *
+ * Parts of this Class were contributed by Steffen Stundzig. Many thanks for the
+ * improvements.
+ * Updates Benoit WIART <b.wiart@proxiad.com>
+ * @deprecated Please move to the RtfWriter2 and associated classes.
+ */
+public class RtfTable {
+    /** Stores the different rows. */
+    private ArrayList rowsList = new ArrayList();
+    /** Stores the RtfWriter, which created this RtfTable. */
+    private RtfWriter writer = null;
+    /** Stores the Table, which this RtfTable is based on. */
+    private Table origTable = null;
+
+
+
+    /**
+     * Create a new <code>RtfTable</code>.
+     *
+     * @param writer The <code>RtfWriter</code> that created this Table
+     */
+    public RtfTable(RtfWriter writer) {
+        super();
+        this.writer = writer;
+    }
+
+    /**
+     * Import a <CODE>Table</CODE> into the <CODE>RtfTable</CODE>.
+     * <P>
+     * @param table A <code>Table</code> specifying the <code>Table</code> to be imported
+     * @param pageWidth An <code>int</code> specifying the page width
+     * @return true if importing the table succeeded
+     */
+    public boolean importTable(Table table, int pageWidth) {
+        origTable = table;
+        // All Cells are pregenerated first, so that cell and rowspanning work
+        Iterator rows = table.iterator();
+        Row row = null;
+
+        int tableWidth = (int) table.getWidth();
+        int cellpadding = (int) (table.getPadding() * RtfWriter.TWIPSFACTOR);
+        int cellspacing = (int) (table.getSpacing() * RtfWriter.TWIPSFACTOR);
+        float[] propWidths = table.getProportionalWidths();
+
+        int borders = table.getBorder();
+        java.awt.Color borderColor = table.getBorderColor();
+        float borderWidth = table.getBorderWidth();
+
+        for (int i = 0; i < table.size(); i++) {
+            RtfRow rtfRow = new RtfRow(writer, this);
+            rtfRow.pregenerateRows(table.getColumns());
+            rowsList.add(rtfRow);
+        }
+        int i = 0;
+        while (rows.hasNext()) {
+            row = (Row) rows.next();
+            row.setHorizontalAlignment(table.getAlignment());
+            RtfRow rtfRow = (RtfRow) rowsList.get(i);
+            rtfRow.importRow(row, propWidths, tableWidth, pageWidth, cellpadding, cellspacing, borders, borderColor, borderWidth, i);
+            i++;
+        }
+        return true;
+    }
+
+    /**
+     * Output the content of the <CODE>RtfTable</CODE> to an OutputStream.
+     *
+     * @param os The <code>OutputStream</code> that the content of the <code>RtfTable</code> is to be written to
+     * @return true if writing the table succeeded
+     * @throws DocumentException
+     * @throws IOException
+     */
+    public boolean writeTable(ByteArrayOutputStream os) throws DocumentException, IOException {
+
+        if(!this.writer.writingHeaderFooter()) {
+            // Added by Benoit WIART <b.wiart@proxiad.com>
+            // Add a new line before each table
+            os.write(RtfWriter.escape);
+            os.write(RtfWriter.paragraph);
+        }
+
+        int size = rowsList.size();
+        for (int i = 0; i < size; i++) {
+            RtfRow row = (RtfRow) rowsList.get(i);
+            row.writeRow(os, i, origTable);
+            os.write((byte) '\n');
+        }
+        if (!writer.writingHeaderFooter()) {
+            os.write(RtfWriter.escape);
+            os.write(RtfWriter.paragraphDefaults);
+            os.write(RtfWriter.escape);
+            os.write(RtfWriter.paragraph);
+            switch (origTable.getAlignment()) {
+                case Element.ALIGN_LEFT:
+                    os.write(RtfWriter.escape);
+                	os.write(RtfWriter.alignLeft);
+                    break;
+                case Element.ALIGN_RIGHT:
+                    os.write(RtfWriter.escape);
+                    os.write(RtfWriter.alignRight);
+                    break;
+                case Element.ALIGN_CENTER:
+                    os.write(RtfWriter.escape);
+                    os.write(RtfWriter.alignCenter);
+                    break;
+                case Element.ALIGN_JUSTIFIED:
+                case Element.ALIGN_JUSTIFIED_ALL:
+                    os.write(RtfWriter.escape);
+                    os.write(RtfWriter.alignJustify);
+                    break;
+            }
+        }
+        return true;
+    }
+
+    /**
+     * <code>RtfCell</code>s call this method to specify that a certain other cell is to be merged with it.
+     *
+     * @param x The column position of the cell to be merged
+     * @param y The row position of the cell to be merged
+     * @param mergeType The merge type specifies the kind of merge to be applied (MERGE_HORIZ_PREV, MERGE_VERT_PREV, MERGE_BOTH_PREV)
+     * @param mergeCell The <code>RtfCell</code> that the cell at x and y is to be merged with
+     */
+    public void setMerge(int x, int y, int mergeType, RtfCell mergeCell) {
+        RtfRow row = (RtfRow) rowsList.get(y);
+        row.setMerge(x, mergeType, mergeCell);
+    }
+
+    /**
+     * This method allows access to the original Table that led to this RtfTable.
+     *
+     * @return The Table object that is the basis of this RtfTable.
+     */
+    protected Table getOriginalTable() {
+        return origTable;
+    }
+}

Property changes on: src/core/com/lowagie/text/rtf/RtfTable.java
___________________________________________________________________
Added: svn:executable
   + *

Index: src/core/com/lowagie/text/rtf/RtfTOC.java
===================================================================
--- src/core/com/lowagie/text/rtf/RtfTOC.java	(revision 0)
+++ src/core/com/lowagie/text/rtf/RtfTOC.java	(revision 0)
@@ -0,0 +1,187 @@
+/**
+ * $Id$
+ *
+ * Copyright 2002 by
+ * <a href="http://www.smb-tec.com">SMB</a>
+ * <a href="mailto:Steffen.Stundzig@smb-tec.com">Steffen.Stundzig@smb-tec.com</a>
+ *
+ * The contents of this file are subject to the Mozilla Public License Version 1.1
+ * (the "License"); you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the License.
+ *
+ * The Original Code is 'iText, a free JAVA-PDF library'.
+ *
+ * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
+ * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
+ * All Rights Reserved.
+ * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
+ * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
+ *
+ * Contributor(s): all the names of the contributors are added in the source code
+ * where applicable.
+ *
+ * Alternatively, the contents of this file may be used under the terms of the
+ * LGPL license (the �GNU LIBRARY GENERAL PUBLIC LICENSE�), in which case the
+ * provisions of LGPL are applicable instead of those above.  If you wish to
+ * allow use of your version of this file only under the terms of the LGPL
+ * License and not to allow others to use your version of this file under
+ * the MPL, indicate your decision by deleting the provisions above and
+ * replace them with the notice and other provisions required by the LGPL.
+ * If you do not delete the provisions above, a recipient may use your version
+ * of this file under either the MPL or the GNU LIBRARY GENERAL PUBLIC LICENSE.
+ *
+ * This library is free software; you can redistribute it and/or modify it
+ * under the terms of the MPL as stated above or under the terms of the GNU
+ * Library General Public License as published by the Free Software Foundation;
+ * either version 2 of the License, or any later version.
+ *
+ * This library is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU Library general Public License for more
+ * details.
+ *
+ * If you didn't download this code from the following link, you should check if
+ * you aren't using an obsolete version:
+ * http://www.lowagie.com/iText/
+ */
+
+package com.lowagie.text.rtf;
+
+import java.io.IOException;
+import java.io.OutputStream;
+
+import com.lowagie.text.Chunk;
+import com.lowagie.text.DocumentException;
+import com.lowagie.text.Font;
+import com.lowagie.text.ExceptionConverter;
+
+/**
+ * This class can be used to insert a table of contents into
+ * the RTF document.
+ * Therefore the field TOC is used. It works great in Word 2000.
+ * StarOffice doesn't support such fields. Other word version
+ * are not tested yet.
+ *
+ * ONLY FOR USE WITH THE RtfWriter NOT with the RtfWriter2.
+ *
+ * This class is based on the RtfWriter-package from Mark Hall.
+ * @author <a href="mailto:Steffen.Stundzig@smb-tec.com">Steffen.Stundzig@smb-tec.com</a>
+ * @version $Revision$Date: 2009/08/28 20:31:00 $
+ * @deprecated Please move to the RtfWriter2 and associated classes. com.lowagie.text.rtf.field.RtfTableOfContents replaces the functionality of this class.
+ */
+public class RtfTOC extends Chunk implements RtfField {
+
+
+    private String      defaultText = "Klicken Sie mit der rechten Maustaste auf diesen Text, um das Inhaltsverzeichnis zu aktualisieren!";
+
+    private boolean     addTOCAsTOCEntry = false;
+
+    private Font        entryFont = null;
+    private String      entryName = null;
+
+
+    /**
+     * @param tocName the headline of the table of contents
+     * @param tocFont the font for the headline
+     */
+    public RtfTOC( String tocName, Font tocFont ) {
+        super( tocName, tocFont );
+    }
+
+    /**
+     * @see com.lowagie.text.rtf.RtfField#write(com.lowagie.text.rtf.RtfWriter, java.io.OutputStream)
+     */
+    public void write( RtfWriter writer, OutputStream out ) throws IOException {
+
+        writer.writeInitialFontSignature( out, this );
+        out.write( RtfWriter.filterSpecialChar( getContent(), true ).getBytes() );
+        writer.writeFinishingFontSignature( out, this );
+
+        if (addTOCAsTOCEntry) {
+            RtfTOCEntry entry = new RtfTOCEntry( entryName, entryFont );
+            entry.hideText();
+            try {
+                writer.add( entry );
+            } catch ( DocumentException de ) {
+                throw new ExceptionConverter(de);
+            }
+        }
+
+        // line break after headline
+        out.write( RtfWriter.escape );
+        out.write( RtfWriter.paragraph );
+        out.write( RtfWriter.delimiter );
+
+        // toc field entry
+        out.write( RtfWriter.openGroup );
+        out.write( RtfWriter.escape );
+        out.write( RtfWriter.field );
+            // field initialization stuff
+            out.write( RtfWriter.openGroup );
+            out.write( RtfWriter.escape );
+            out.write( RtfWriter.fieldContent );
+            out.write( RtfWriter.delimiter );
+            out.write( "TOC".getBytes() );
+            // create the TOC based on the 'toc entries'
+            out.write( RtfWriter.delimiter );
+            out.write( RtfWriter.escape );
+            out.write( RtfWriter.escape );
+            out.write( "f".getBytes() );
+            out.write( RtfWriter.delimiter );
+            // create Hyperlink TOC Entrie
+            out.write( RtfWriter.escape );
+            out.write( RtfWriter.escape );
+            out.write( "h".getBytes() );
+            out.write( RtfWriter.delimiter );
+            // create the TOC based on the paragraph level
+            out.write( RtfWriter.delimiter );
+            out.write( RtfWriter.escape );
+            out.write( RtfWriter.escape );
+            out.write( "u".getBytes() );
+            out.write( RtfWriter.delimiter );
+            // create the TOC based on the paragraph headlines 1-5
+            out.write( RtfWriter.delimiter );
+            out.write( RtfWriter.escape );
+            out.write( RtfWriter.escape );
+            out.write( "o".getBytes() );
+            out.write( RtfWriter.delimiter );
+            out.write( "\"1-5\"".getBytes() );
+            out.write( RtfWriter.delimiter );
+            out.write( RtfWriter.closeGroup );
+
+            // field default result stuff
+            out.write( RtfWriter.openGroup );
+            out.write( RtfWriter.escape );
+            out.write( RtfWriter.fieldDisplay );
+            out.write( RtfWriter.delimiter );
+            out.write( defaultText.getBytes() );
+            out.write( RtfWriter.delimiter );
+            out.write( RtfWriter.closeGroup );
+        out.write( RtfWriter.closeGroup );
+    }
+
+
+    /**
+     * Add a toc entry
+     * @param entryName	the name of the entry
+     * @param entryFont the font to be used for the entry
+     */
+    public void addTOCAsTOCEntry( String entryName, Font entryFont ) {
+        this.addTOCAsTOCEntry = true;
+        this.entryFont = entryFont;
+        this.entryName = entryName;
+    }
+
+
+    /**
+     * Sets the default text of the Table of Contents
+     * @param text the default text
+     */
+    public void setDefaultText( String text ) {
+        this.defaultText = text;
+    }
+}

Property changes on: src/core/com/lowagie/text/rtf/RtfTOC.java
___________________________________________________________________
Added: svn:executable
   + *

Index: src/core/com/lowagie/text/markup/MarkupTags.java
===================================================================
--- src/core/com/lowagie/text/markup/MarkupTags.java	(revision 0)
+++ src/core/com/lowagie/text/markup/MarkupTags.java	(revision 0)
@@ -0,0 +1,266 @@
+/*
+ * $Id$
+ * $Name$
+ *
+ * Copyright 2001, 2002 by Bruno Lowagie.
+ *
+ * The contents of this file are subject to the Mozilla Public License Version 1.1
+ * (the "License"); you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the License.
+ *
+ * The Original Code is 'iText, a free JAVA-PDF library'.
+ *
+ * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
+ * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
+ * All Rights Reserved.
+ * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
+ * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
+ *
+ * Contributor(s): all the names of the contributors are added in the source code
+ * where applicable.
+ *
+ * Alternatively, the contents of this file may be used under the terms of the
+ * LGPL license (the "GNU LIBRARY GENERAL PUBLIC LICENSE"), in which case the
+ * provisions of LGPL are applicable instead of those above.  If you wish to
+ * allow use of your version of this file only under the terms of the LGPL
+ * License and not to allow others to use your version of this file under
+ * the MPL, indicate your decision by deleting the provisions above and
+ * replace them with the notice and other provisions required by the LGPL.
+ * If you do not delete the provisions above, a recipient may use your version
+ * of this file under either the MPL or the GNU LIBRARY GENERAL PUBLIC LICENSE.
+ *
+ * This library is free software; you can redistribute it and/or modify it
+ * under the terms of the MPL as stated above or under the terms of the GNU
+ * Library General Public License as published by the Free Software Foundation;
+ * either version 2 of the License, or any later version.
+ *
+ * This library is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU Library general Public License for more
+ * details.
+ *
+ * If you didn't download this code from the following link, you should check if
+ * you aren't using an obsolete version:
+ * http://www.lowagie.com/iText/
+ */
+
+package com.lowagie.text.markup;
+
+/**
+ * A class that contains all the possible tagnames and their attributes.
+ */
+
+public class MarkupTags {
+	
+	// iText specific
+	
+	/** the key for any tag */
+	public static final String ITEXT_TAG = "tag";
+
+	// HTML tags
+
+	/** the markup for the body part of a file */
+	public static final String HTML_TAG_BODY = "body";
+	
+	/** The DIV tag. */
+	public static final String HTML_TAG_DIV = "div";
+
+	/** This is a possible HTML-tag. */
+	public static final String HTML_TAG_LINK = "link";
+
+	/** The SPAN tag. */
+	public static final String HTML_TAG_SPAN = "span";
+
+	// HTML attributes
+
+	/** the height attribute. */
+	public static final String HTML_ATTR_HEIGHT = "height";
+
+	/** the hyperlink reference attribute. */
+	public static final String HTML_ATTR_HREF = "href";
+
+	/** This is a possible HTML attribute for the LINK tag. */
+	public static final String HTML_ATTR_REL = "rel";
+
+	/** This is used for inline css style information */
+	public static final String HTML_ATTR_STYLE = "style";
+
+	/** This is a possible HTML attribute for the LINK tag. */
+	public static final String HTML_ATTR_TYPE = "type";
+
+	/** This is a possible HTML attribute. */
+	public static final String HTML_ATTR_STYLESHEET = "stylesheet";
+
+	/** the width attribute. */
+	public static final String HTML_ATTR_WIDTH = "width";
+
+	/** attribute for specifying externally defined CSS class */
+	public static final String HTML_ATTR_CSS_CLASS = "class";
+
+	/** The ID attribute. */
+	public static final String HTML_ATTR_CSS_ID = "id";
+
+	// HTML values
+	
+	/** This is a possible value for the language attribute (SCRIPT tag). */
+	public static final String HTML_VALUE_JAVASCRIPT = "text/javascript";
+	
+	/** This is a possible HTML attribute for the LINK tag. */
+	public static final String HTML_VALUE_CSS = "text/css";
+
+	// CSS keys
+
+	/** the CSS tag for background color */
+	public static final String CSS_KEY_BGCOLOR = "background-color";
+
+	/** the CSS tag for text color */
+	public static final String CSS_KEY_COLOR = "color";
+
+	/** CSS key that indicate the way something has to be displayed */
+	public static final String CSS_KEY_DISPLAY = "display";
+
+	/** the CSS tag for the font family */
+	public static final String CSS_KEY_FONTFAMILY = "font-family";
+
+	/** the CSS tag for the font size */
+	public static final String CSS_KEY_FONTSIZE = "font-size";
+
+	/** the CSS tag for the font style */
+	public static final String CSS_KEY_FONTSTYLE = "font-style";
+
+	/** the CSS tag for the font weight */
+	public static final String CSS_KEY_FONTWEIGHT = "font-weight";
+
+	/** the CSS tag for text decorations */
+	public static final String CSS_KEY_LINEHEIGHT = "line-height";
+
+	/** the CSS tag for the margin of an object */
+	public static final String CSS_KEY_MARGIN = "margin";
+
+	/** the CSS tag for the margin of an object */
+	public static final String CSS_KEY_MARGINLEFT = "margin-left";
+
+	/** the CSS tag for the margin of an object */
+	public static final String CSS_KEY_MARGINRIGHT = "margin-right";
+
+	/** the CSS tag for the margin of an object */
+	public static final String CSS_KEY_MARGINTOP = "margin-top";
+
+	/** the CSS tag for the margin of an object */
+	public static final String CSS_KEY_MARGINBOTTOM = "margin-bottom";
+
+	/** the CSS tag for the margin of an object */
+	public static final String CSS_KEY_PADDING = "padding";
+
+	/** the CSS tag for the margin of an object */
+	public static final String CSS_KEY_PADDINGLEFT = "padding-left";
+
+	/** the CSS tag for the margin of an object */
+	public static final String CSS_KEY_PADDINGRIGHT = "padding-right";
+
+	/** the CSS tag for the margin of an object */
+	public static final String CSS_KEY_PADDINGTOP = "padding-top";
+
+	/** the CSS tag for the margin of an object */
+	public static final String CSS_KEY_PADDINGBOTTOM = "padding-bottom";
+
+	/** the CSS tag for the margin of an object */
+	public static final String CSS_KEY_BORDERCOLOR = "border-color";
+
+	/** the CSS tag for the margin of an object */
+	public static final String CSS_KEY_BORDERWIDTH = "border-width";
+
+	/** the CSS tag for the margin of an object */
+	public static final String CSS_KEY_BORDERWIDTHLEFT = "border-left-width";
+
+	/** the CSS tag for the margin of an object */
+	public static final String CSS_KEY_BORDERWIDTHRIGHT = "border-right-width";
+
+	/** the CSS tag for the margin of an object */
+	public static final String CSS_KEY_BORDERWIDTHTOP = "border-top-width";
+
+	/** the CSS tag for the margin of an object */
+	public static final String CSS_KEY_BORDERWIDTHBOTTOM = "border-bottom-width";
+
+	/** the CSS tag for adding a page break when the document is printed */
+	public static final String CSS_KEY_PAGE_BREAK_AFTER = "page-break-after";
+
+	/** the CSS tag for adding a page break when the document is printed */
+	public static final String CSS_KEY_PAGE_BREAK_BEFORE = "page-break-before";
+
+	/** the CSS tag for the horizontal alignment of an object */
+	public static final String CSS_KEY_TEXTALIGN = "text-align";
+
+	/** the CSS tag for text decorations */
+	public static final String CSS_KEY_TEXTDECORATION = "text-decoration";
+
+	/** the CSS tag for text decorations */
+	public static final String CSS_KEY_VERTICALALIGN = "vertical-align";
+
+	/** the CSS tag for the visibility of objects */
+	public static final String CSS_KEY_VISIBILITY = "visibility";
+
+	// CSS values
+
+	/** value for the CSS tag for adding a page break when the document is printed */
+	public static final String CSS_VALUE_ALWAYS = "always";
+
+	/** A possible value for the DISPLAY key */
+	public static final String CSS_VALUE_BLOCK = "block";
+
+	/** a CSS value for text font weight */
+	public static final String CSS_VALUE_BOLD = "bold";
+
+	/** the value if you want to hide objects. */
+	public static final String CSS_VALUE_HIDDEN = "hidden";
+
+	/** A possible value for the DISPLAY key */
+	public static final String CSS_VALUE_INLINE = "inline";
+	
+	/** a CSS value for text font style */
+	public static final String CSS_VALUE_ITALIC = "italic";
+
+	/** a CSS value for text decoration */
+	public static final String CSS_VALUE_LINETHROUGH = "line-through";
+
+	/** A possible value for the DISPLAY key */
+	public static final String CSS_VALUE_LISTITEM = "list-item";
+	
+	/** a CSS value */
+	public static final String CSS_VALUE_NONE = "none";
+
+	/** a CSS value */
+	public static final String CSS_VALUE_NORMAL = "normal";
+
+	/** a CSS value for text font style */
+	public static final String CSS_VALUE_OBLIQUE = "oblique";
+
+	/** A possible value for the DISPLAY key */
+	public static final String CSS_VALUE_TABLE = "table";
+
+	/** A possible value for the DISPLAY key */
+	public static final String CSS_VALUE_TABLEROW = "table-row";
+
+	/** A possible value for the DISPLAY key */
+	public static final String CSS_VALUE_TABLECELL = "table-cell";
+
+	/** the CSS value for a horizontal alignment of an object */
+	public static final String CSS_VALUE_TEXTALIGNLEFT = "left";
+
+	/** the CSS value for a horizontal alignment of an object */
+	public static final String CSS_VALUE_TEXTALIGNRIGHT = "right";
+
+	/** the CSS value for a horizontal alignment of an object */
+	public static final String CSS_VALUE_TEXTALIGNCENTER = "center";
+
+	/** the CSS value for a horizontal alignment of an object */
+	public static final String CSS_VALUE_TEXTALIGNJUSTIFY = "justify";
+
+	/** a CSS value for text decoration */
+	public static final String CSS_VALUE_UNDERLINE = "underline";
+
+}
\ No newline at end of file
Index: src/core/com/lowagie/text/xml/XmlToXXX.java
===================================================================
--- src/core/com/lowagie/text/xml/XmlToXXX.java	(revision 0)
+++ src/core/com/lowagie/text/xml/XmlToXXX.java	(revision 0)
@@ -0,0 +1,147 @@
+/*
+ * Copyright 2002 by Matt Benson.
+ *
+ * The contents of this file are subject to the Mozilla Public License Version 1.1
+ * (the "License"); you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the License.
+ *
+ * The Original Code is 'iText, a free JAVA-PDF library'.
+ *
+ * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
+ * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
+ * All Rights Reserved.
+ * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
+ * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
+ *
+ * Contributor(s): all the names of the contributors are added in the source code
+ * where applicable.
+ *
+ * Alternatively, the contents of this file may be used under the terms of the
+ * LGPL license (the "GNU LIBRARY GENERAL PUBLIC LICENSE"), in which case the
+ * provisions of LGPL are applicable instead of those above.  If you wish to
+ * allow use of your version of this file only under the terms of the LGPL
+ * License and not to allow others to use your version of this file under
+ * the MPL, indicate your decision by deleting the provisions above and
+ * replace them with the notice and other provisions required by the LGPL.
+ * If you do not delete the provisions above, a recipient may use your version
+ * of this file under either the MPL or the GNU LIBRARY GENERAL PUBLIC LICENSE.
+ *
+ * This library is free software; you can redistribute it and/or modify it
+ * under the terms of the MPL as stated above or under the terms of the GNU
+ * Library General Public License as published by the Free Software Foundation;
+ * either version 2 of the License, or any later version.
+ *
+ * This library is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU Library general Public License for more
+ * details.
+ *
+ * If you didn't download this code from the following link, you should check if
+ * you aren't using an obsolete version:
+ * http://www.lowagie.com/iText/
+ */
+
+package com.lowagie.text.xml;
+
+
+import java.lang.reflect.Field;
+import java.lang.reflect.Modifier;
+import java.io.InputStream;
+import java.io.OutputStream;
+
+import com.lowagie.text.Document;
+import com.lowagie.text.PageSize;
+import com.lowagie.text.Rectangle;
+import com.lowagie.text.DocumentException;
+
+
+/**
+ * Generates an specific file from an iText XML file.
+ *
+ * @version 1.0
+ * @author <a href="mailto:orangeherbert@users.sourceforge.net">Matt Benson</a>
+ */
+public abstract class XmlToXXX
+{
+	
+	protected Rectangle pageSize;
+	
+	
+/**
+ * Construct an <CODE>XmlToXXX</CODE> with the default page size.
+ */
+	public XmlToXXX()
+	{
+		this(PageSize.LETTER);
+	}//end default constructor
+	
+	
+/**
+ * Construct an <CODE>XmlToXXX</CODE> with the specified page size.
+ * @param pageSize   <CODE>String</CODE> page size name from
+ * <CODE>com.lowagie.text.PageSize</CODE>.
+ */
+	public XmlToXXX(String pageSize)
+	{
+		this(getPageSize(pageSize));
+	}//end constructor(String)
+	
+	
+	private XmlToXXX(Rectangle pageSize)
+	{
+		this.pageSize = pageSize;
+	}//end constructor(Rectangle)
+	
+	
+/**
+ * Parse the XML from the specified <CODE>InputStream</CODE>, writing to the
+ * specified <CODE>OutputStream</CODE>.
+ * @param in    the <CODE>InputStream</CODE> from which the XML is read.
+ * @param out   the <CODE>OutputStream</CODE> to which the result is written.
+ * @throws DocumentException if document errors occur.
+ */
+	public final void parse(InputStream in, OutputStream out)
+	 throws DocumentException
+	{
+		Document doc = new Document(pageSize);
+
+		addWriter(doc, out);
+		XmlParser.parse(doc, in);
+	}//end parse
+	
+	
+	private static Rectangle getPageSize(String pageSize)
+	{
+		Rectangle result = PageSize.LETTER;
+		Field fld = null;
+		try
+		{
+			fld = PageSize.class.getDeclaredField(pageSize.toUpperCase());
+			result = (fld != null
+			 && Modifier.isStatic(fld.getModifiers())
+			 && fld.getType().equals(Rectangle.class)) ? (Rectangle)(fld.get(null))
+			 : result;
+		}//end try to get field
+		catch (Exception ex)
+		{
+			System.err.println(ex.getMessage());
+		}//end catch Exception
+		return result;
+	}//end getPageSize
+	
+
+/**
+ * Add a <CODE>DocWriter</CODE> for the specified <CODE>Document</CODE> and
+ * <CODE>OutputStream</CODE>.
+ * @param doc The document to which content will be added
+ * @param out The outputstream to which the document will be sent
+ * @throws DocumentException if document errors occur.
+ */	
+	protected abstract void addWriter(Document doc, OutputStream out)
+	 throws DocumentException;
+	
+}//end class XmlToXXX
Index: src/core/com/lowagie/text/rtf/RtfWriter.java
===================================================================
--- src/core/com/lowagie/text/rtf/RtfWriter.java	(revision 0)
+++ src/core/com/lowagie/text/rtf/RtfWriter.java	(revision 0)
@@ -0,0 +1,2298 @@
+/*
+ * $Id$
+ * $Name$
+ *
+ * Copyright 2001, 2002 by Mark Hall
+ *
+ * The contents of this file are subject to the Mozilla Public License Version 1.1
+ * (the "License"); you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the License.
+ *
+ * The Original Code is 'iText, a free JAVA-PDF library'.
+ *
+ * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
+ * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
+ * All Rights Reserved.
+ * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
+ * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
+ *
+ * Contributor(s): all the names of the contributors are added in the source code
+ * where applicable.
+ *
+ * Alternatively, the contents of this file may be used under the terms of the
+ * LGPL license (the ?GNU LIBRARY GENERAL PUBLIC LICENSE?), in which case the
+ * provisions of LGPL are applicable instead of those above.  If you wish to
+ * allow use of your version of this file only under the terms of the LGPL
+ * License and not to allow others to use your version of this file under
+ * the MPL, indicate your decision by deleting the provisions above and
+ * replace them with the notice and other provisions required by the LGPL.
+ * If you do not delete the provisions above, a recipient may use your version
+ * of this file under either the MPL or the GNU LIBRARY GENERAL PUBLIC LICENSE.
+ *
+ * This library is free software; you can redistribute it and/or modify it
+ * under the terms of the MPL as stated above or under the terms of the GNU
+ * Library General Public License as published by the Free Software Foundation;
+ * either version 2 of the License, or any later version.
+ *
+ * This library is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU Library general Public License for more
+ * details.
+ *
+ * If you didn't download this code from the following link, you should check if
+ * you aren't using an obsolete version:
+ * http://www.lowagie.com/iText/
+ */
+
+package com.lowagie.text.rtf;
+
+import com.lowagie.text.*;
+
+import java.io.*;
+import java.util.ArrayList;
+import java.util.ListIterator;
+import java.util.Iterator;
+import java.util.Calendar;
+import java.util.Date;
+import java.awt.Color;
+import java.text.SimpleDateFormat;
+import java.text.ParsePosition;
+import com.lowagie.text.pdf.codec.wmf.MetaDo;
+
+/**
+ * If you are creating a new project using the rtf part of iText, please
+ * consider using the new RtfWriter2. The RtfWriter is in bug-fix-only mode,
+ * will be deprecated end of 2005 and removed end of 2007.
+ *
+ * A <CODE>DocWriter</CODE> class for Rich Text Files (RTF).
+ * <P>
+ * A <CODE>RtfWriter</CODE> can be added as a <CODE>DocListener</CODE>
+ * to a certain <CODE>Document</CODE> by getting an instance.
+ * Every <CODE>Element</CODE> added to the original <CODE>Document</CODE>
+ * will be written to the <CODE>OutputStream</CODE> of this <CODE>RtfWriter</CODE>.
+ * <P>
+ * Example:
+ * <BLOCKQUOTE><PRE>
+ * // creation of the document with a certain size and certain margins
+ * Document document = new Document(PageSize.A4, 50, 50, 50, 50);
+ * try {
+ *    // this will write RTF to the Standard OutputStream
+ *    <STRONG>RtfWriter.getInstance(document, System.out);</STRONG>
+ *    // this will write Rtf to a file called text.rtf
+ *    <STRONG>RtfWriter.getInstance(document, new FileOutputStream("text.rtf"));</STRONG>
+ *    // this will write Rtf to for instance the OutputStream of a HttpServletResponse-object
+ *    <STRONG>RtfWriter.getInstance(document, response.getOutputStream());</STRONG>
+ * }
+ * catch(DocumentException de) {
+ *    System.err.println(de.getMessage());
+ * }
+ * // this will close the document and all the OutputStreams listening to it
+ * <STRONG>document.close();</CODE>
+ * </PRE></BLOCKQUOTE>
+ * <P>
+ * <STRONG>LIMITATIONS</STRONG><BR>
+ * There are currently still a few limitations on what the RTF Writer can do:
+ * <ul>
+ *    <li>Watermarks</li>
+ *    <li>Viewer preferences</li>
+ *    <li>Encryption</li>
+ *    <li>Embedded fonts</li>
+ *    <li>Phrases with a leading</li>
+ *    <li>Lists with non-bullet symbols</li>
+ *    <li>Nested tables</li>
+ *    <li>Images other than JPEG and PNG</li>
+ *    <li>Rotated images</li>
+ * </ul>
+ * <br />
+ *
+ * @author <a href="mailto:mhall@myrealbox.com">Mark.Hall@myrealbox.com</a>
+ * @author Steffen Stundzig
+ * @author <a href="ericmattes@yahoo.com">Eric Mattes</a>
+ * @author <a href="raul.wegmann@uam.es">Raul Wegmann</a>
+ * @deprecated The RtfWriter is deprecated and will be removed from the iText library end of 2007
+ */
+public class RtfWriter extends DocWriter implements DocListener {
+    /**
+     * Static Constants
+     */
+
+    /**
+     * General
+     */
+
+    /** This is the escape character which introduces RTF tags. */
+    public static final byte escape = (byte) '\\';
+
+    /** This is another escape character which introduces RTF tags. */
+    private static final byte[] extendedEscape = "\\*\\".getBytes();
+
+    /** This is the delimiter between RTF tags and normal text. */
+    protected static final byte delimiter = (byte) ' ';
+
+    /** This is another delimiter between RTF tags and normal text. */
+    private static final byte commaDelimiter = (byte) ';';
+
+    /** This is the character for beginning a new group. */
+    public static final byte openGroup = (byte) '{';
+
+    /** This is the character for closing a group. */
+    public static final byte closeGroup = (byte) '}';
+
+    /**
+     * RTF Information
+     */
+
+    /** RTF begin and version. */
+    private static final byte[] docBegin = "rtf1".getBytes();
+
+    /** RTF encoding. */
+    private static final byte[] ansi = "ansi".getBytes();
+
+    /** RTF encoding codepage. */
+    private static final byte[] ansiCodepage = "ansicpg".getBytes();
+
+    /**
+     *Font Data
+     */
+
+    /** Begin the font table tag. */
+    private static final byte[] fontTable = "fonttbl".getBytes();
+
+    /** Font number tag. */
+    protected static final byte fontNumber = (byte) 'f';
+
+    /** Font size tag. */
+    protected static final byte[] fontSize = "fs".getBytes();
+
+    /** Font color tag. */
+    protected static final byte[] fontColor = "cf".getBytes();
+
+    /** Modern font tag. */
+    private static final byte[] fontModern = "fmodern".getBytes();
+
+    /** Swiss font tag. */
+    private static final byte[] fontSwiss = "fswiss".getBytes();
+
+    /** Roman font tag. */
+    private static final byte[] fontRoman = "froman".getBytes();
+
+    /** Tech font tag. */
+    private static final byte[] fontTech = "ftech".getBytes();
+
+    /** Font charset tag. */
+    private static final byte[] fontCharset = "fcharset".getBytes();
+
+    /** Font Courier tag. */
+    private static final byte[] fontCourier = "Courier".getBytes();
+
+    /** Font Arial tag. */
+    private static final byte[] fontArial = "Arial".getBytes();
+
+    /** Font Symbol tag. */
+    private static final byte[] fontSymbol = "Symbol".getBytes();
+
+    /** Font Times New Roman tag. */
+    private static final byte[] fontTimesNewRoman = "Times New Roman".getBytes();
+
+    /** Font Windings tag. */
+    private static final byte[] fontWindings = "Windings".getBytes();
+
+    /** Default Font. */
+    private static final byte[] defaultFont = "deff".getBytes();
+
+    /** First indent tag. */
+    private static final byte[] firstIndent = "fi".getBytes();
+
+    /** Left indent tag. */
+    private static final byte[] listIndent = "li".getBytes();
+
+    /** Right indent tag. */
+    private static final byte[] rightIndent = "ri".getBytes();
+
+    /**
+     * Sections / Paragraphs
+     */
+
+    /** Reset section defaults tag. */
+    private static final byte[] sectionDefaults = "sectd".getBytes();
+
+    /** Begin new section tag. */
+    private static final byte[] section = "sect".getBytes();
+
+    /** Reset paragraph defaults tag. */
+    public static final byte[] paragraphDefaults = "pard".getBytes();
+
+    /** Begin new paragraph tag. */
+    public static final byte[] paragraph = "par".getBytes();
+
+	/** Page width of a section. */
+	public static final byte[] sectionPageWidth = "pgwsxn".getBytes();
+
+	/** Page height of a section. */
+	public static final byte[] sectionPageHeight = "pghsxn".getBytes();
+
+    /**
+     * Lists
+     */
+
+    /** Begin the List Table */
+    private static final byte[] listtableGroup = "listtable".getBytes();
+
+    /** Begin the List Override Table */
+    private static final byte[] listoverridetableGroup = "listoverridetable".getBytes();
+
+    /** Begin a List definition */
+    private static final byte[] listDefinition = "list".getBytes();
+
+    /** List Template ID */
+    private static final byte[] listTemplateID = "listtemplateid".getBytes();
+
+    /** RTF Writer outputs hybrid lists */
+    private static final byte[] hybridList = "hybrid".getBytes();
+
+    /** Current List level */
+    private static final byte[] listLevelDefinition = "listlevel".getBytes();
+
+    /** Level numbering (old) */
+    private static final byte[] listLevelTypeOld = "levelnfc".getBytes();
+
+    /** Level numbering (new) */
+    private static final byte[] listLevelTypeNew = "levelnfcn".getBytes();
+
+    /** Level alignment (old) */
+    private static final byte[] listLevelAlignOld = "leveljc".getBytes();
+
+    /** Level alignment (new) */
+    private static final byte[] listLevelAlignNew = "leveljcn".getBytes();
+
+    /** Level starting number */
+    private static final byte[] listLevelStartAt = "levelstartat".getBytes();
+
+    /** Level text group */
+    private static final byte[] listLevelTextDefinition = "leveltext".getBytes();
+
+    /** Filler for Level Text Length */
+    private static final byte[] listLevelTextLength = "\'0".getBytes();
+
+    /** Level Text Numbering Style */
+    private static final byte[] listLevelTextStyleNumbers = "\'00.".getBytes();
+
+    /** Level Text Bullet Style */
+    private static final byte[] listLevelTextStyleBullet = "u-3913 ?".getBytes();
+
+    /** Level Numbers Definition */
+    private static final byte[] listLevelNumbersDefinition = "levelnumbers".getBytes();
+
+    /** Filler for Level Numbers */
+    private static final byte[] listLevelNumbers = "\\'0".getBytes();
+
+    /** Tab Stop */
+    private static final byte[] tabStop = "tx".getBytes();
+
+    /** Actual list begin */
+    private static final byte[] listBegin = "ls".getBytes();
+
+    /** Current list level */
+    private static final byte[] listCurrentLevel = "ilvl".getBytes();
+
+    /** List text group for older browsers */
+    private static final byte[] listTextOld = "listtext".getBytes();
+
+    /** Tab */
+    private static final byte[] tab = "tab".getBytes();
+
+    /** Old Bullet Style */
+    private static final byte[] listBulletOld = "\'b7".getBytes();
+
+    /** Current List ID */
+    private static final byte[] listID = "listid".getBytes();
+
+    /** List override */
+    private static final byte[] listOverride = "listoverride".getBytes();
+
+    /** Number of overrides */
+    private static final byte[] listOverrideCount = "listoverridecount".getBytes();
+
+    /**
+     * Text Style
+     */
+
+    /** Bold tag. */
+    protected static final byte bold = (byte) 'b';
+
+    /** Italic tag. */
+    protected static final byte italic = (byte) 'i';
+
+    /** Underline tag. */
+    protected static final byte[] underline = "ul".getBytes();
+
+    /** Strikethrough tag. */
+    protected static final byte[] strikethrough = "strike".getBytes();
+
+    /** Text alignment left tag. */
+    public static final byte[] alignLeft = "ql".getBytes();
+
+    /** Text alignment center tag. */
+    public static final byte[] alignCenter = "qc".getBytes();
+
+    /** Text alignment right tag. */
+    public static final byte[] alignRight = "qr".getBytes();
+
+    /** Text alignment justify tag. */
+    public static final byte[] alignJustify = "qj".getBytes();
+
+    /**
+     * Colors
+     */
+
+    /** Begin colour table tag. */
+    private static final byte[] colorTable = "colortbl".getBytes();
+
+    /** Red value tag. */
+    private static final byte[] colorRed = "red".getBytes();
+
+    /** Green value tag. */
+    private static final byte[] colorGreen = "green".getBytes();
+
+    /** Blue value tag. */
+    private static final byte[] colorBlue = "blue".getBytes();
+
+    /**
+     * Information Group
+     */
+
+    /** Begin the info group tag.*/
+    private static final byte[] infoBegin = "info".getBytes();
+
+    /** Author tag. */
+    private static final byte[] metaAuthor = "author".getBytes();
+
+    /** Subject tag. */
+    private static final byte[] metaSubject = "subject".getBytes();
+
+    /** Keywords tag. */
+    private static final byte[] metaKeywords = "keywords".getBytes();
+
+    /** Title tag. */
+    private static final byte[] metaTitle = "title".getBytes();
+
+    /** Producer tag. */
+    private static final byte[] metaProducer = "operator".getBytes();
+
+    /** Creation Date tag. */
+    private static final byte[] metaCreationDate = "creationdate".getBytes();
+
+    /** Year tag. */
+    private static final byte[] year = "yr".getBytes();
+
+    /** Month tag. */
+    private static final byte[] month = "mo".getBytes();
+
+    /** Day tag. */
+    private static final byte[] day = "dy".getBytes();
+
+    /** Hour tag. */
+    private static final byte[] hour = "hr".getBytes();
+
+    /** Minute tag. */
+    private static final byte[] minute = "min".getBytes();
+
+    /** Second tag. */
+    private static final byte[] second = "sec".getBytes();
+
+    /** Start superscript. */
+    private static final byte[] startSuper = "super".getBytes();
+
+    /** Start subscript. */
+    private static final byte[] startSub = "sub".getBytes();
+
+    /** End super/sub script. */
+    private static final byte[] endSuperSub = "nosupersub".getBytes();
+
+    /**
+     * Header / Footer
+     */
+
+    /** Title Page tag */
+    private static final byte[] titlePage = "titlepg".getBytes();
+
+    /** Facing pages tag */
+    private static final byte[] facingPages = "facingp".getBytes();
+
+    /** Begin header group tag. */
+    private static final byte[] headerBegin = "header".getBytes();
+
+    /** Begin footer group tag. */
+    private static final byte[] footerBegin = "footer".getBytes();
+
+    // header footer 'left', 'right', 'first'
+    private static final byte[] headerlBegin = "headerl".getBytes();
+
+    private static final byte[] footerlBegin = "footerl".getBytes();
+
+    private static final byte[] headerrBegin = "headerr".getBytes();
+
+    private static final byte[] footerrBegin = "footerr".getBytes();
+
+    private static final byte[] headerfBegin = "headerf".getBytes();
+
+    private static final byte[] footerfBegin = "footerf".getBytes();
+
+    /**
+     * Paper Properties
+     */
+
+    /** Paper width tag. */
+    private static final byte[] rtfPaperWidth = "paperw".getBytes();
+
+    /** Paper height tag. */
+    private static final byte[] rtfPaperHeight = "paperh".getBytes();
+
+    /** Margin left tag. */
+    private static final byte[] rtfMarginLeft = "margl".getBytes();
+
+    /** Margin right tag. */
+    private static final byte[] rtfMarginRight = "margr".getBytes();
+
+    /** Margin top tag. */
+    private static final byte[] rtfMarginTop = "margt".getBytes();
+
+    /** Margin bottom tag. */
+    private static final byte[] rtfMarginBottom = "margb".getBytes();
+
+    /** New Page tag. */
+    private static final byte[] newPage = "page".getBytes();
+
+    /** Document Landscape tag 1. */
+    private static final byte[] landscapeTag1 = "landscape".getBytes();
+
+    /** Document Landscape tag 2. */
+    private static final byte[] landscapeTag2 = "lndscpsxn".getBytes();
+
+    /**
+     * Annotations
+     */
+
+    /** Annotation ID tag. */
+    private static final byte[] annotationID = "atnid".getBytes();
+
+    /** Annotation Author tag. */
+    private static final byte[] annotationAuthor = "atnauthor".getBytes();
+
+    /** Annotation text tag. */
+    private static final byte[] annotation = "annotation".getBytes();
+
+    /**
+     * Images
+     */
+
+    /** Begin the main Picture group tag */
+    private static final byte[] pictureGroup = "shppict".getBytes();
+
+    /** Begin the picture tag */
+    private static final byte[] picture = "pict".getBytes();
+
+    /** PNG Image */
+    private static final byte[] picturePNG = "pngblip".getBytes();
+
+    /** JPEG Image */
+    private static final byte[] pictureJPEG = "jpegblip".getBytes();
+
+    /** BMP Image */
+    private static final byte[] pictureBMP = "dibitmap0".getBytes();
+
+    /** WMF Image */
+    private static final byte[] pictureWMF = "wmetafile8".getBytes();
+
+    /** Picture width */
+    private static final byte[] pictureWidth = "picw".getBytes();
+
+    /** Picture height */
+    private static final byte[] pictureHeight = "pich".getBytes();
+
+    /** Picture scale horizontal percent */
+    private static final byte[] pictureScaleX = "picscalex".getBytes();
+
+    /** Picture scale vertical percent */
+    private static final byte[] pictureScaleY = "picscaley".getBytes();
+
+    /**
+     * Fields (for page numbering)
+     */
+
+    /** Begin field tag */
+    protected static final byte[] field = "field".getBytes();
+
+    /** Content fo the field */
+    protected static final byte[] fieldContent = "fldinst".getBytes();
+
+    /** PAGE numbers */
+    protected static final byte[] fieldPage = "PAGE".getBytes();
+
+    /** HYPERLINK field */
+    protected static final byte[] fieldHyperlink = "HYPERLINK".getBytes();
+
+    /** Last page number (not used) */
+    protected static final byte[] fieldDisplay = "fldrslt".getBytes();
+
+
+    /** Class variables */
+
+    /**
+     * Because of the way RTF works and the way itext works, the text has to be
+     * stored and is only written to the actual OutputStream at the end.
+     */
+
+    /** This <code>ArrayList</code> contains all fonts used in the document. */
+    private ArrayList fontList = new ArrayList();
+
+    /** This <code>ArrayList</code> contains all colours used in the document. */
+    private ArrayList colorList = new ArrayList();
+
+    /** This <code>ByteArrayOutputStream</code> contains the main body of the document. */
+    private ByteArrayOutputStream content = null;
+
+    /** This <code>ByteArrayOutputStream</code> contains the information group. */
+    private ByteArrayOutputStream info = null;
+
+    /** This <code>ByteArrayOutputStream</code> contains the list table. */
+    private ByteArrayOutputStream listtable = null;
+
+    /** This <code>ByteArrayOutputStream</code> contains the list override table. */
+    private ByteArrayOutputStream listoverride = null;
+
+    /** Document header. */
+    private HeaderFooter header = null;
+
+    /** Document footer. */
+    private HeaderFooter footer = null;
+
+    /** Left margin. */
+    private int marginLeft = 1800;
+
+    /** Right margin. */
+    private int marginRight = 1800;
+
+    /** Top margin. */
+    private int marginTop = 1440;
+
+    /** Bottom margin. */
+    private int marginBottom = 1440;
+
+    /** Page width. */
+    private int pageWidth = 11906;
+
+    /** Page height. */
+    private int pageHeight = 16838;
+
+    /** Factor to use when converting. */
+    public final static double TWIPSFACTOR = 20;//20.57140;
+
+    /** Current list ID. */
+    private int currentListID = 1;
+
+    /** List of current Lists. */
+    private ArrayList listIds = null;
+
+    /** Current List Level. */
+    private int listLevel = 0;
+
+    /** Current maximum List Level. */
+    private int maxListLevel = 0;
+
+    /** Write a TOC */
+    private boolean writeTOC = false;
+
+    /** Special title page */
+    private boolean hasTitlePage = false;
+
+    /** Currently writing either Header or Footer */
+    private boolean inHeaderFooter = false;
+
+    /** Currently writing a Table */
+    private boolean inTable = false;
+
+    /** Landscape or Portrait Document */
+    private boolean landscape = false;
+
+    /** Protected Constructor */
+
+    /**
+     * Constructs a <CODE>RtfWriter</CODE>.
+     *
+     * @param doc         The <CODE>Document</CODE> that is to be written as RTF
+     * @param os          The <CODE>OutputStream</CODE> the writer has to write to.
+     */
+
+    protected RtfWriter(Document doc, OutputStream os) {
+        super(doc, os);
+        document.addDocListener(this);
+        initDefaults();
+    }
+
+    /** Public functions special to the RtfWriter */
+
+    /**
+     * This method controls whether TOC entries are automatically generated
+     *
+     * @param writeTOC    boolean value indicating whether a TOC is to be generated
+     */
+    public void setGenerateTOCEntries(boolean writeTOC) {
+        this.writeTOC = writeTOC;
+    }
+
+    /**
+     * Gets the current setting of writeTOC
+     *
+     * @return    boolean value indicating whether a TOC is being generated
+     */
+    public boolean getGeneratingTOCEntries() {
+        return writeTOC;
+    }
+
+    /**
+     * This method controls whether the first page is a title page
+     *
+     * @param hasTitlePage    boolean value indicating whether the first page is a title page
+     */
+    public void setHasTitlePage(boolean hasTitlePage) {
+        this.hasTitlePage = hasTitlePage;
+    }
+
+    /**
+     * Gets the current setting of hasTitlePage
+     *
+     * @return    boolean value indicating whether the first page is a title page
+     */
+    public boolean getHasTitlePage() {
+        return hasTitlePage;
+    }
+
+    /**
+     * Explicitly sets the page format to use.
+     * Otherwise the RtfWriter will try to guess the format by comparing pagewidth and pageheight
+     *
+     * @param landscape boolean value indicating whether we are using landscape format or not
+     */
+    public void setLandscape(boolean landscape) {
+        this.landscape = landscape;
+    }
+
+    /**
+     * Returns the current landscape setting
+     *
+     * @return boolean value indicating the current page format
+     */
+    public boolean getLandscape() {
+        return landscape;
+    }
+
+    /** Public functions from the DocWriter Interface */
+
+    /**
+     * Gets an instance of the <CODE>RtfWriter</CODE>.
+     *
+     * @param document    The <CODE>Document</CODE> that has to be written
+     * @param os  The <CODE>OutputStream</CODE> the writer has to write to.
+     * @return    a new <CODE>RtfWriter</CODE>
+     */
+    public static RtfWriter getInstance(Document document, OutputStream os) {
+        return (new RtfWriter(document, os));
+    }
+
+    /**
+     * Signals that the <CODE>Document</CODE> has been opened and that
+     * <CODE>Elements</CODE> can be added.
+     */
+    public void open() {
+        super.open();
+    }
+
+    /**
+     * Signals that the <CODE>Document</CODE> was closed and that no other
+     * <CODE>Elements</CODE> will be added.
+     * <p>
+     * The content of the font table, color table, information group, content, header, footer are merged into the final
+     * <code>OutputStream</code>
+     */
+    public void close() {
+        writeDocument();
+        super.close();
+    }
+
+    /**
+     * Adds the footer to the bottom of the <CODE>Document</CODE>.
+     * @param footer
+     */
+    public void setFooter(HeaderFooter footer) {
+        this.footer = footer;
+        processHeaderFooter(this.footer);
+    }
+
+    /**
+     * Adds the header to the top of the <CODE>Document</CODE>.
+     * @param header
+     */
+    public void setHeader(HeaderFooter header) {
+        this.header = header;
+        processHeaderFooter(this.header);
+    }
+
+    /**
+     * Resets the footer.
+     */
+    public void resetFooter() {
+        setFooter(null);
+    }
+
+    /**
+     * Resets the header.
+     */
+    public void resetHeader() {
+        setHeader(null);
+    }
+
+    /**
+     * Tells the <code>RtfWriter</code> that a new page is to be begun.
+     *
+     * @return <code>true</code> if a new Page was begun.
+     */
+    public boolean newPage() {
+        try {
+            content.write(escape);
+            content.write(newPage);
+            content.write(escape);
+            content.write(paragraph);
+        } catch (IOException e) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * Sets the page margins
+     *
+     * @param marginLeft The left margin
+     * @param marginRight The right margin
+     * @param marginTop The top margin
+     * @param marginBottom The bottom margin
+     *
+     * @return <code>true</code> if the page margins were set.
+     */
+    public boolean setMargins(float marginLeft, float marginRight, float marginTop, float marginBottom) {
+        this.marginLeft = (int) (marginLeft * TWIPSFACTOR);
+        this.marginRight = (int) (marginRight * TWIPSFACTOR);
+        this.marginTop = (int) (marginTop * TWIPSFACTOR);
+        this.marginBottom = (int) (marginBottom * TWIPSFACTOR);
+        return true;
+    }
+
+    /**
+     * Sets the page size
+     *
+     * @param pageSize A <code>Rectangle</code> specifying the page size
+     *
+     * @return <code>true</code> if the page size was set
+     */
+    public boolean setPageSize(Rectangle pageSize) {
+        if (!parseFormat(pageSize, false)) {
+            pageWidth = (int) (pageSize.getWidth() * TWIPSFACTOR);
+            pageHeight = (int) (pageSize.getHeight() * TWIPSFACTOR);
+            landscape = pageWidth > pageHeight;
+        }
+        return true;
+    }
+
+    /**
+     * Write the table of contents.
+     *
+     * @param tocTitle The title that will be displayed above the TOC
+     * @param titleFont The <code>Font</code> that will be used for the tocTitle
+     * @param showTOCasEntry Set this to true if you want the TOC to appear as an entry in the TOC
+     * @param showTOCEntryFont Use this <code>Font</code> to specify what Font to use when showTOCasEntry is true
+     *
+     * @return <code>true</code> if the TOC was added.
+     */
+    public boolean writeTOC(String tocTitle, Font titleFont, boolean showTOCasEntry, Font showTOCEntryFont) {
+        try {
+            RtfTOC toc = new RtfTOC(tocTitle, titleFont);
+            if (showTOCasEntry) {
+                toc.addTOCAsTOCEntry(tocTitle, showTOCEntryFont);
+            }
+            add(new Paragraph(toc));
+        } catch (DocumentException de) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * Signals that an <CODE>Element</CODE> was added to the <CODE>Document</CODE>.
+     *
+     * @param element A high level object to add
+     * @return    <CODE>true</CODE> if the element was added, <CODE>false</CODE> if not.
+     * @throws    DocumentException   if a document isn't open yet, or has been closed
+     */
+    public boolean add(Element element) throws DocumentException {
+        if (pause) {
+            return false;
+        }
+        return addElement(element, content);
+    }
+
+
+    /** Private functions */
+
+    /**
+     * Adds an <CODE>Element</CODE> to the <CODE>Document</CODE>.
+     * @param element the high level element to add
+     * @param out the outputstream to which the RTF data is sent
+     * @return    <CODE>true</CODE> if the element was added, <CODE>false</CODE> if not.
+     * @throws    DocumentException   if a document isn't open yet, or has been closed
+     */
+    protected boolean addElement(Element element, ByteArrayOutputStream out) throws DocumentException {
+        try {
+            switch (element.type()) {
+                case Element.CHUNK:
+                    writeChunk((Chunk) element, out);
+                    break;
+                case Element.PARAGRAPH:
+                    writeParagraph((Paragraph) element, out);
+                    break;
+                case Element.ANCHOR:
+                    writeAnchor((Anchor) element, out);
+                    break;
+                case Element.PHRASE:
+                    writePhrase((Phrase) element, out);
+                    break;
+                case Element.CHAPTER:
+                case Element.SECTION:
+                    writeSection((Section) element, out);
+                    break;
+                case Element.LIST:
+                    writeList((com.lowagie.text.List) element, out);
+                    break;
+                case Element.TABLE:
+                	try {
+                		writeTable((Table) element, out);
+                	}
+                	catch(ClassCastException cce) {
+                		writeTable(((SimpleTable)element).createTable(), out);
+                	}
+                    break;
+                case Element.ANNOTATION:
+                    writeAnnotation((Annotation) element, out);
+                    break;
+                case Element.IMGRAW:
+                case Element.IMGTEMPLATE:
+                case Element.JPEG:
+                    Image img = (Image)element;
+                    writeImage(img, out);
+                    break;
+
+                case Element.AUTHOR:
+                    writeMeta(metaAuthor, (Meta) element);
+                    break;
+                case Element.SUBJECT:
+                    writeMeta(metaSubject, (Meta) element);
+                    break;
+                case Element.KEYWORDS:
+                    writeMeta(metaKeywords, (Meta) element);
+                    break;
+                case Element.TITLE:
+                    writeMeta(metaTitle, (Meta) element);
+                    break;
+                case Element.PRODUCER:
+                    writeMeta(metaProducer, (Meta) element);
+                    break;
+                case Element.CREATIONDATE:
+                    writeMeta(metaCreationDate, (Meta) element);
+                    break;
+            }
+        } catch (IOException e) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * Write the beginning of a new <code>Section</code>
+     *
+     * @param sectionElement The <code>Section</code> be written
+     * @param out The <code>ByteArrayOutputStream</code> to write to
+     *
+     * @throws IOException
+     * @throws DocumentException
+     */
+    private void writeSection(Section sectionElement, ByteArrayOutputStream out) throws IOException, DocumentException {
+        if (sectionElement.type() == Element.CHAPTER) {
+            out.write(escape);
+            out.write(sectionDefaults);
+            writeSectionDefaults(out);
+        }
+        if (sectionElement.getTitle() != null) {
+            if (writeTOC) {
+                StringBuffer title = new StringBuffer("");
+                for (ListIterator li = sectionElement.getTitle().getChunks().listIterator(); li.hasNext();) {
+                    title.append(((Chunk) li.next()).getContent());
+                }
+                add(new RtfTOCEntry(title.toString(), sectionElement.getTitle().getFont()));
+            } else {
+                add(sectionElement.getTitle());
+            }
+            out.write(escape);
+            out.write(paragraph);
+        }
+        sectionElement.process(this);
+        if (sectionElement.type() == Element.CHAPTER) {
+            out.write(escape);
+            out.write(section);
+        }
+        if (sectionElement.type() == Element.SECTION) {
+            out.write(escape);
+            out.write(paragraph);
+        }
+    }
+
+    /**
+     * Write the beginning of a new <code>Paragraph</code>
+     *
+     * @param paragraphElement The <code>Paragraph</code> to be written
+     * @param out The <code>ByteArrayOutputStream</code> to write to
+     *
+     * @throws IOException
+     */
+    private void writeParagraph(Paragraph paragraphElement, ByteArrayOutputStream out) throws IOException {
+        out.write(escape);
+        out.write(paragraphDefaults);
+        if (inTable) {
+            out.write(escape);
+            out.write(RtfCell.cellInTable);
+        }
+        switch (paragraphElement.getAlignment()) {
+            case Element.ALIGN_LEFT:
+                out.write(escape);
+                out.write(alignLeft);
+                break;
+            case Element.ALIGN_RIGHT:
+                out.write(escape);
+                out.write(alignRight);
+                break;
+            case Element.ALIGN_CENTER:
+                out.write(escape);
+                out.write(alignCenter);
+                break;
+            case Element.ALIGN_JUSTIFIED:
+            case Element.ALIGN_JUSTIFIED_ALL:
+                out.write(escape);
+                out.write(alignJustify);
+                break;
+        }
+        out.write(escape);
+        out.write(listIndent);
+        writeInt(out, (int) (paragraphElement.getIndentationLeft() * TWIPSFACTOR));
+        out.write(escape);
+        out.write(rightIndent);
+        writeInt(out, (int) (paragraphElement.getIndentationRight() * TWIPSFACTOR));
+        Iterator chunks = paragraphElement.getChunks().iterator();
+        while (chunks.hasNext()) {
+            Chunk ch = (Chunk) chunks.next();
+            ch.setFont(paragraphElement.getFont().difference(ch.getFont()));
+        }
+        ByteArrayOutputStream save = content;
+        content = out;
+        paragraphElement.process(this);
+        content = save;
+        if (!inTable) {
+            out.write(escape);
+            out.write(paragraph);
+        }
+    }
+
+    /**
+     * Write a <code>Phrase</code>.
+     *
+     * @param phrase  The <code>Phrase</code> item to be written
+     * @param out     The <code>ByteArrayOutputStream</code> to write to
+     *
+     * @throws IOException
+     */
+    private void writePhrase(Phrase phrase, ByteArrayOutputStream out) throws IOException {
+        out.write(escape);
+        out.write(paragraphDefaults);
+        if (inTable) {
+            out.write(escape);
+            out.write(RtfCell.cellInTable);
+        }
+        Iterator chunks = phrase.getChunks().iterator();
+        while (chunks.hasNext()) {
+            Chunk ch = (Chunk) chunks.next();
+            ch.setFont(phrase.getFont().difference(ch.getFont()));
+        }
+        ByteArrayOutputStream save = content;
+        content = out;
+        phrase.process(this);
+        content = save;
+    }
+
+    /**
+     * Write an <code>Anchor</code>. Anchors are treated like Phrases.
+     *
+     * @param anchor  The <code>Chunk</code> item to be written
+     * @param out     The <code>ByteArrayOutputStream</code> to write to
+     *
+     * @throws IOException
+     */
+    private void writeAnchor(Anchor anchor, ByteArrayOutputStream out) throws IOException {
+        if (anchor.getUrl() != null) {
+            out.write(openGroup);
+            out.write(escape);
+            out.write(field);
+            out.write(openGroup);
+            out.write(extendedEscape);
+            out.write(fieldContent);
+            out.write(openGroup);
+            out.write(fieldHyperlink);
+            out.write(delimiter);
+            out.write(anchor.getUrl().toString().getBytes());
+            out.write(closeGroup);
+            out.write(closeGroup);
+            out.write(openGroup);
+            out.write(escape);
+            out.write(fieldDisplay);
+            out.write(delimiter);
+            writePhrase(anchor, out);
+            out.write(closeGroup);
+            out.write(closeGroup);
+        } else {
+            writePhrase(anchor, out);
+        }
+    }
+
+    /**
+     * Write a <code>Chunk</code> and all its font properties.
+     *
+     * @param chunk The <code>Chunk</code> item to be written
+     * @param out The <code>ByteArrayOutputStream</code> to write to
+     *
+     * @throws IOException
+     * @throws DocumentException
+     */
+    private void writeChunk(Chunk chunk, ByteArrayOutputStream out) throws IOException, DocumentException {
+        if (chunk instanceof RtfField) {
+            ((RtfField) chunk).write(this, out);
+        } else {
+            if (chunk.getImage() != null) {
+                writeImage(chunk.getImage(), out);
+            } else {
+                writeInitialFontSignature(out, chunk);
+                out.write(filterSpecialChar(chunk.getContent(), false).getBytes());
+                writeFinishingFontSignature(out, chunk);
+            }
+        }
+    }
+
+
+    protected void writeInitialFontSignature(OutputStream out, Chunk chunk) throws IOException {
+        Font font = chunk.getFont();
+
+        out.write(escape);
+        out.write(fontNumber);
+        if (!font.getFamilyname().equalsIgnoreCase("unknown")) {
+            writeInt(out, addFont(font));
+        } else {
+            writeInt(out, 0);
+        }
+        out.write(escape);
+        out.write(fontSize);
+        if (font.getSize() > 0) {
+            writeInt(out, (int) (font.getSize() * 2));
+        } else {
+            writeInt(out, 20);
+        }
+        out.write(escape);
+        out.write(fontColor);
+        writeInt(out, addColor(font.getColor()));
+        if (font.isBold()) {
+            out.write(escape);
+            out.write(bold);
+        }
+        if (font.isItalic()) {
+            out.write(escape);
+            out.write(italic);
+        }
+        if (font.isUnderlined()) {
+            out.write(escape);
+            out.write(underline);
+        }
+        if (font.isStrikethru()) {
+            out.write(escape);
+            out.write(strikethrough);
+        }
+
+        /*
+         * Superscript / Subscript added by Scott Dietrich (sdietrich@emlab.com)
+         */
+        if (chunk.getAttributes() != null) {
+            Float f = (Float) chunk.getAttributes().get(Chunk.SUBSUPSCRIPT);
+            if (f != null)
+                if (f.floatValue() > 0) {
+                    out.write(escape);
+                    out.write(startSuper);
+                } else if (f.floatValue() < 0) {
+                    out.write(escape);
+                    out.write(startSub);
+                }
+        }
+
+        out.write(delimiter);
+    }
+
+
+    protected void writeFinishingFontSignature(OutputStream out, Chunk chunk) throws IOException {
+        Font font = chunk.getFont();
+
+        if (font.isBold()) {
+            out.write(escape);
+            out.write(bold);
+            writeInt(out, 0);
+        }
+        if (font.isItalic()) {
+            out.write(escape);
+            out.write(italic);
+            writeInt(out, 0);
+        }
+        if (font.isUnderlined()) {
+            out.write(escape);
+            out.write(underline);
+            writeInt(out, 0);
+        }
+        if (font.isStrikethru()) {
+            out.write(escape);
+            out.write(strikethrough);
+            writeInt(out, 0);
+        }
+
+        /*
+         * Superscript / Subscript added by Scott Dietrich (sdietrich@emlab.com)
+         */
+        if (chunk.getAttributes() != null) {
+            Float f = (Float) chunk.getAttributes().get(Chunk.SUBSUPSCRIPT);
+            if (f != null)
+                if (f.floatValue() != 0) {
+                    out.write(escape);
+                    out.write(endSuperSub);
+                }
+        }
+    }
+
+    /**
+     * Write a <code>ListItem</code>
+     *
+     * @param listItem The <code>ListItem</code> to be written
+     * @param out The <code>ByteArrayOutputStream</code> to write to
+     *
+     * @throws IOException
+     * @throws DocumentException
+     */
+    private void writeListElement(ListItem listItem, ByteArrayOutputStream out) throws IOException, DocumentException {
+        Iterator chunks = listItem.getChunks().iterator();
+        while (chunks.hasNext()) {
+            Chunk ch = (Chunk) chunks.next();
+            addElement(ch, out);
+        }
+        out.write(escape);
+        out.write(paragraph);
+    }
+
+    /**
+     * Write a <code>List</code>
+     *
+     * @param list The <code>List</code> to be written
+     * @param out The <code>ByteArrayOutputStream</code> to write to
+     *
+     * @throws    IOException
+     * @throws    DocumentException
+     */
+    private void writeList(com.lowagie.text.List list, ByteArrayOutputStream out) throws IOException, DocumentException {
+        int type = 0;
+        int align = 0;
+        int fontNr = addFont(new Font(Font.SYMBOL, 10, Font.NORMAL, new Color(0, 0, 0)));
+        if (!list.isNumbered()) type = 23;
+        if (listLevel == 0) {
+            maxListLevel = 0;
+            listtable.write(openGroup);
+            listtable.write(escape);
+            listtable.write(listDefinition);
+            int i = getRandomInt();
+            listtable.write(escape);
+            listtable.write(listTemplateID);
+            writeInt(listtable, i);
+            listtable.write(escape);
+            listtable.write(hybridList);
+            listtable.write((byte) '\n');
+        }
+        if (listLevel >= maxListLevel) {
+            maxListLevel++;
+            listtable.write(openGroup);
+            listtable.write(escape);
+            listtable.write(listLevelDefinition);
+            listtable.write(escape);
+            listtable.write(listLevelTypeOld);
+            writeInt(listtable, type);
+            listtable.write(escape);
+            listtable.write(listLevelTypeNew);
+            writeInt(listtable, type);
+            listtable.write(escape);
+            listtable.write(listLevelAlignOld);
+            writeInt(listtable, align);
+            listtable.write(escape);
+            listtable.write(listLevelAlignNew);
+            writeInt(listtable, align);
+            listtable.write(escape);
+            listtable.write(listLevelStartAt);
+            writeInt(listtable, 1);
+            listtable.write(openGroup);
+            listtable.write(escape);
+            listtable.write(listLevelTextDefinition);
+            listtable.write(escape);
+            listtable.write(listLevelTextLength);
+            if (list.isNumbered()) {
+                writeInt(listtable, 2);
+            } else {
+                writeInt(listtable, 1);
+            }
+            listtable.write(escape);
+            if (list.isNumbered()) {
+                listtable.write(listLevelTextStyleNumbers);
+            } else {
+                listtable.write(listLevelTextStyleBullet);
+            }
+            listtable.write(commaDelimiter);
+            listtable.write(closeGroup);
+            listtable.write(openGroup);
+            listtable.write(escape);
+            listtable.write(listLevelNumbersDefinition);
+            if (list.isNumbered()) {
+                listtable.write(delimiter);
+                listtable.write(listLevelNumbers);
+                writeInt(listtable, listLevel + 1);
+            }
+            listtable.write(commaDelimiter);
+            listtable.write(closeGroup);
+            if (!list.isNumbered()) {
+                listtable.write(escape);
+                listtable.write(fontNumber);
+                writeInt(listtable, fontNr);
+            }
+            listtable.write(escape);
+            listtable.write(firstIndent);
+            writeInt(listtable, (int) (list.getIndentationLeft() * TWIPSFACTOR * -1));
+            listtable.write(escape);
+            listtable.write(listIndent);
+            writeInt(listtable, (int) ((list.getIndentationLeft() + list.getSymbolIndent()) * TWIPSFACTOR));
+            listtable.write(escape);
+            listtable.write(rightIndent);
+            writeInt(listtable, (int) (list.getIndentationRight() * TWIPSFACTOR));
+            listtable.write(escape);
+            listtable.write(tabStop);
+            writeInt(listtable, (int) (list.getSymbolIndent() * TWIPSFACTOR));
+            listtable.write(closeGroup);
+            listtable.write((byte) '\n');
+        }
+        // Actual List Begin in Content
+        out.write(escape);
+        out.write(paragraphDefaults);
+        out.write(escape);
+        out.write(alignLeft);
+        out.write(escape);
+        out.write(firstIndent);
+        writeInt(out, (int) (list.getIndentationLeft() * TWIPSFACTOR * -1));
+        out.write(escape);
+        out.write(listIndent);
+        writeInt(out, (int) ((list.getIndentationLeft() + list.getSymbolIndent()) * TWIPSFACTOR));
+        out.write(escape);
+        out.write(rightIndent);
+        writeInt(out, (int) (list.getIndentationRight() * TWIPSFACTOR));
+        out.write(escape);
+        out.write(fontSize);
+        writeInt(out, 20);
+        out.write(escape);
+        out.write(listBegin);
+        writeInt(out, currentListID);
+        if (listLevel > 0) {
+            out.write(escape);
+            out.write(listCurrentLevel);
+            writeInt(out, listLevel);
+        }
+        out.write(openGroup);
+        ListIterator listItems = list.getItems().listIterator();
+        Element listElem;
+        int count = 1;
+        while (listItems.hasNext()) {
+            listElem = (Element) listItems.next();
+            if (listElem.type() == Element.CHUNK) {
+                listElem = new ListItem((Chunk) listElem);
+            }
+            if (listElem.type() == Element.LISTITEM) {
+                out.write(openGroup);
+                out.write(escape);
+                out.write(listTextOld);
+                out.write(escape);
+                out.write(paragraphDefaults);
+                out.write(escape);
+                out.write(fontNumber);
+                if (list.isNumbered()) {
+                    writeInt(out, addFont(new Font(Font.TIMES_ROMAN, Font.NORMAL, 10, new Color(0, 0, 0))));
+                } else {
+                    writeInt(out, fontNr);
+                }
+                out.write(escape);
+                out.write(firstIndent);
+                writeInt(out, (int) (list.getIndentationLeft() * TWIPSFACTOR * -1));
+                out.write(escape);
+                out.write(listIndent);
+                writeInt(out, (int) ((list.getIndentationLeft() + list.getSymbolIndent()) * TWIPSFACTOR));
+                out.write(escape);
+                out.write(rightIndent);
+                writeInt(out, (int) (list.getIndentationRight() * TWIPSFACTOR));
+                out.write(delimiter);
+                if (list.isNumbered()) {
+                    writeInt(out, count);
+                    out.write(".".getBytes());
+                } else {
+                    out.write(escape);
+                    out.write(listBulletOld);
+                }
+                out.write(escape);
+                out.write(tab);
+                out.write(closeGroup);
+                writeListElement((ListItem) listElem, out);
+                count++;
+            } else if (listElem.type() == Element.LIST) {
+                listLevel++;
+                writeList((com.lowagie.text.List) listElem, out);
+                listLevel--;
+                out.write(escape);
+                out.write(paragraphDefaults);
+                out.write(escape);
+                out.write(alignLeft);
+                out.write(escape);
+                out.write(firstIndent);
+                writeInt(out, (int) (list.getIndentationLeft() * TWIPSFACTOR * -1));
+                out.write(escape);
+                out.write(listIndent);
+                writeInt(out, (int) ((list.getIndentationLeft() + list.getSymbolIndent()) * TWIPSFACTOR));
+                out.write(escape);
+                out.write(rightIndent);
+                writeInt(out, (int) (list.getIndentationRight() * TWIPSFACTOR));
+                out.write(escape);
+                out.write(fontSize);
+                writeInt(out, 20);
+                out.write(escape);
+                out.write(listBegin);
+                writeInt(out, currentListID);
+                if (listLevel > 0) {
+                    out.write(escape);
+                    out.write(listCurrentLevel);
+                    writeInt(out, listLevel);
+                }
+            }
+            out.write((byte) '\n');
+        }
+        out.write(closeGroup);
+        if (listLevel == 0) {
+            int i = getRandomInt();
+            listtable.write(escape);
+            listtable.write(listID);
+            writeInt(listtable, i);
+            listtable.write(closeGroup);
+            listtable.write((byte) '\n');
+            listoverride.write(openGroup);
+            listoverride.write(escape);
+            listoverride.write(listOverride);
+            listoverride.write(escape);
+            listoverride.write(listID);
+            writeInt(listoverride, i);
+            listoverride.write(escape);
+            listoverride.write(listOverrideCount);
+            writeInt(listoverride, 0);
+            listoverride.write(escape);
+            listoverride.write(listBegin);
+            writeInt(listoverride, currentListID);
+            currentListID++;
+            listoverride.write(closeGroup);
+            listoverride.write((byte) '\n');
+        }
+        out.write(escape);
+        out.write(paragraphDefaults);
+    }
+
+    /**
+     * Write a <code>Table</code>.
+     *
+     * @param table The <code>table</code> to be written
+     * @param out The <code>ByteArrayOutputStream</code> to write to
+     *
+     * Currently no nesting of tables is supported. If a cell contains anything but a Cell Object it is ignored.
+     *
+     * @throws IOException
+     * @throws DocumentException
+     */
+    private void writeTable(Table table, ByteArrayOutputStream out) throws IOException, DocumentException {
+        inTable = true;
+        table.complete();
+        RtfTable rtfTable = new RtfTable(this);
+        rtfTable.importTable(table, pageWidth - marginLeft - marginRight);
+        rtfTable.writeTable(out);
+        inTable = false;
+    }
+
+
+    /**
+     * Write an <code>Image</code>.
+     *
+     * @param image The <code>image</code> to be written
+     * @param out The <code>ByteArrayOutputStream</code> to write to
+     *
+     * At the moment only PNG and JPEG Images are supported.
+     *
+     * @throws IOException
+     * @throws DocumentException
+     */
+    private void writeImage(Image image, ByteArrayOutputStream out) throws IOException, DocumentException {
+        int type = image.getOriginalType();
+        if (!(type == Image.ORIGINAL_JPEG || type == Image.ORIGINAL_BMP
+            || type == Image.ORIGINAL_PNG || type == Image.ORIGINAL_WMF))
+            throw new DocumentException("Only BMP, PNG, WMF and JPEG images are supported by the RTF Writer");
+        switch (image.getAlignment()) {
+            case Element.ALIGN_LEFT:
+                out.write(escape);
+                out.write(alignLeft);
+                break;
+            case Element.ALIGN_RIGHT:
+                out.write(escape);
+                out.write(alignRight);
+                break;
+            case Element.ALIGN_CENTER:
+                out.write(escape);
+                out.write(alignCenter);
+                break;
+            case Element.ALIGN_JUSTIFIED:
+                out.write(escape);
+                out.write(alignJustify);
+                break;
+        }
+        out.write(openGroup);
+        out.write(extendedEscape);
+        out.write(pictureGroup);
+        out.write(openGroup);
+        out.write(escape);
+        out.write(picture);
+        out.write(escape);
+        switch (type) {
+            case Image.ORIGINAL_JPEG:
+                out.write(pictureJPEG);
+                break;
+            case Image.ORIGINAL_PNG:
+                out.write(picturePNG);
+                break;
+            case Image.ORIGINAL_WMF:
+            case Image.ORIGINAL_BMP:
+                out.write(pictureWMF);
+                break;
+        }
+        out.write(escape);
+        out.write(pictureWidth);
+        writeInt(out, (int) (image.getPlainWidth() * TWIPSFACTOR));
+        out.write(escape);
+        out.write(pictureHeight);
+        writeInt(out, (int) (image.getPlainHeight() * TWIPSFACTOR));
+
+
+// For some reason this messes up the intended image size. It makes it too big. Weird
+//
+//        out.write(escape);
+//        out.write(pictureIntendedWidth);
+//        writeInt(out, (int) (image.plainWidth() * twipsFactor));
+//        out.write(escape);
+//        out.write(pictureIntendedHeight);
+//        writeInt(out, (int) (image.plainHeight() * twipsFactor));
+
+
+        if (image.getWidth() > 0) {
+            out.write(escape);
+            out.write(pictureScaleX);
+            writeInt(out, (int) (100 / image.getWidth() * image.getPlainWidth()));
+        }
+        if (image.getHeight() > 0) {
+            out.write(escape);
+            out.write(pictureScaleY);
+            writeInt(out, (int) (100 / image.getHeight() * image.getPlainHeight()));
+        }
+        out.write(delimiter);
+        InputStream imgIn;
+        if (type == Image.ORIGINAL_BMP) {
+            imgIn = new ByteArrayInputStream(MetaDo.wrapBMP(image));
+        }
+        else {
+            if (image.getOriginalData() == null) {
+                imgIn = image.getUrl().openStream();
+            } else {
+                imgIn = new ByteArrayInputStream(image.getOriginalData());
+            }
+            if (type == Image.ORIGINAL_WMF) { //remove the placeable header
+                long skipLength = 22;
+            	while(skipLength > 0) {
+            	    skipLength = skipLength - imgIn.skip(skipLength);
+            	}
+            }
+        }
+        int buffer = -1;
+        int count = 0;
+        out.write((byte) '\n');
+        while ((buffer = imgIn.read()) != -1) {
+            String helperStr = Integer.toHexString(buffer);
+            if (helperStr.length() < 2) helperStr = "0" + helperStr;
+            out.write(helperStr.getBytes());
+            count++;
+            if (count == 64) {
+                out.write((byte) '\n');
+                count = 0;
+            }
+        }
+        imgIn.close();
+        out.write(closeGroup);
+        out.write(closeGroup);
+        out.write((byte) '\n');
+    }
+
+    /**
+     * Write an <code>Annotation</code>
+     *
+     * @param annotationElement The <code>Annotation</code> to be written
+     * @param out The <code>ByteArrayOutputStream</code> to write to
+     *
+     * @throws IOException
+     */
+    private void writeAnnotation(Annotation annotationElement, ByteArrayOutputStream out) throws IOException {
+        int id = getRandomInt();
+        out.write(openGroup);
+        out.write(extendedEscape);
+        out.write(annotationID);
+        out.write(delimiter);
+        writeInt(out, id);
+        out.write(closeGroup);
+        out.write(openGroup);
+        out.write(extendedEscape);
+        out.write(annotationAuthor);
+        out.write(delimiter);
+        out.write(annotationElement.title().getBytes());
+        out.write(closeGroup);
+        out.write(openGroup);
+        out.write(extendedEscape);
+        out.write(annotation);
+        out.write(escape);
+        out.write(paragraphDefaults);
+        out.write(delimiter);
+        out.write(annotationElement.content().getBytes());
+        out.write(closeGroup);
+    }
+
+    /**
+     * Add a <code>Meta</code> element. It is written to the Inforamtion Group
+     * and merged with the main <code>ByteArrayOutputStream</code> when the
+     * Document is closed.
+     *
+     * @param metaName The type of <code>Meta</code> element to be added
+     * @param meta The <code>Meta</code> element to be added
+     *
+     * Currently only the Meta Elements Author, Subject, Keywords, Title, Producer and CreationDate are supported.
+     *
+     * @throws IOException
+     */
+    private void writeMeta(byte[] metaName, Meta meta) throws IOException {
+        info.write(openGroup);
+        try {
+            info.write(escape);
+            info.write(metaName);
+            info.write(delimiter);
+            if (meta.type() == Meta.CREATIONDATE) {
+                writeFormatedDateTime(meta.getContent());
+            } else {
+                info.write(meta.getContent().getBytes());
+            }
+        } finally {
+            info.write(closeGroup);
+        }
+    }
+
+    /**
+     * Writes a date. The date is formated <strong>Year, Month, Day, Hour, Minute, Second</strong>
+     *
+     * @param date The date to be written
+     *
+     * @throws IOException
+     */
+    private void writeFormatedDateTime(String date) throws IOException {
+        Calendar cal = Calendar.getInstance();
+        SimpleDateFormat sdf = new SimpleDateFormat("EEE MMM dd HH:mm:ss zzz yyyy");
+        ParsePosition pp = new ParsePosition(0);
+        Date d = sdf.parse(date, pp);
+        if (d == null) {
+            d = new Date();
+        }
+        cal.setTime(d);
+        info.write(escape);
+        info.write(year);
+        writeInt(info, cal.get(Calendar.YEAR));
+        info.write(escape);
+        info.write(month);
+        writeInt(info, cal.get(Calendar.MONTH));
+        info.write(escape);
+        info.write(day);
+        writeInt(info, cal.get(Calendar.DAY_OF_MONTH));
+        info.write(escape);
+        info.write(hour);
+        writeInt(info, cal.get(Calendar.HOUR_OF_DAY));
+        info.write(escape);
+        info.write(minute);
+        writeInt(info, cal.get(Calendar.MINUTE));
+        info.write(escape);
+        info.write(second);
+        writeInt(info, cal.get(Calendar.SECOND));
+    }
+
+    /**
+     * Add a new <code>Font</code> to the list of fonts. If the <code>Font</code>
+     * already exists in the list of fonts, then it is not added again.
+     *
+     * @param newFont The <code>Font</code> to be added
+     *
+     * @return The index of the <code>Font</code> in the font list
+     */
+    protected int addFont(Font newFont) {
+        int fn = -1;
+
+        for (int i = 0; i < fontList.size(); i++) {
+            if (newFont.getFamilyname().equals(((Font) fontList.get(i)).getFamilyname())) {
+                fn = i;
+            }
+        }
+        if (fn == -1) {
+            fontList.add(newFont);
+            return fontList.size() - 1;
+        }
+        return fn;
+    }
+
+    /**
+     * Add a new <code>Color</code> to the list of colours. If the <code>Color</code>
+     * already exists in the list of colours, then it is not added again.
+     *
+     * @param newColor The <code>Color</code> to be added
+     *
+     * @return The index of the <code>color</code> in the colour list
+     */
+    protected int addColor(Color newColor) {
+        int cn = 0;
+        if (newColor == null) {
+            return cn;
+        }
+        cn = colorList.indexOf(newColor);
+        if (cn == -1) {
+            colorList.add(newColor);
+            return colorList.size() - 1;
+        }
+        return cn;
+    }
+
+    /**
+     * Merge all the different <code>ArrayList</code>s and <code>ByteArrayOutputStream</code>s
+     * to the final <code>ByteArrayOutputStream</code>
+     *
+     * @return <code>true</code> if all information was sucessfully written to the <code>ByteArrayOutputStream</code>
+     */
+    private boolean writeDocument() {
+        try {
+            writeDocumentIntro();
+            writeFontList();
+            os.write((byte) '\n');
+            writeColorList();
+            os.write((byte) '\n');
+            writeList();
+            os.write((byte) '\n');
+            writeInfoGroup();
+            os.write((byte) '\n');
+            writeDocumentFormat();
+            os.write((byte) '\n');
+            ByteArrayOutputStream hf = new ByteArrayOutputStream();
+            writeSectionDefaults(hf);
+            hf.writeTo(os);
+            content.writeTo(os);
+            os.write(closeGroup);
+            return true;
+        } catch (IOException e) {
+            System.err.println(e.getMessage());
+            return false;
+        }
+
+    }
+
+    /** Write the Rich Text file settings
+     * @throws IOException
+     */
+    private void writeDocumentIntro() throws IOException {
+        os.write(openGroup);
+        os.write(escape);
+        os.write(docBegin);
+        os.write(escape);
+        os.write(ansi);
+        os.write(escape);
+        os.write(ansiCodepage);
+        writeInt(os, 1252);
+        os.write((byte)'\n');
+        os.write(escape);
+        os.write(defaultFont);
+        writeInt(os, 0);
+    }
+
+    /**
+     * Write the font list to the final <code>ByteArrayOutputStream</code>
+     * @throws IOException
+     */
+    private void writeFontList() throws IOException {
+        Font fnt;
+
+        os.write(openGroup);
+        os.write(escape);
+        os.write(fontTable);
+        for (int i = 0; i < fontList.size(); i++) {
+            fnt = (Font) fontList.get(i);
+            os.write(openGroup);
+            os.write(escape);
+            os.write(fontNumber);
+            writeInt(os, i);
+            os.write(escape);
+            switch (Font.getFamilyIndex(fnt.getFamilyname())) {
+                case Font.COURIER:
+                    os.write(fontModern);
+                    os.write(escape);
+                    os.write(fontCharset);
+                    writeInt(os, 0);
+                    os.write(delimiter);
+                    os.write(fontCourier);
+                    break;
+                case Font.HELVETICA:
+                    os.write(fontSwiss);
+                    os.write(escape);
+                    os.write(fontCharset);
+                    writeInt(os, 0);
+                    os.write(delimiter);
+                    os.write(fontArial);
+                    break;
+                case Font.SYMBOL:
+                    os.write(fontRoman);
+                    os.write(escape);
+                    os.write(fontCharset);
+                    writeInt(os, 2);
+                    os.write(delimiter);
+                    os.write(fontSymbol);
+                    break;
+                case Font.TIMES_ROMAN:
+                    os.write(fontRoman);
+                    os.write(escape);
+                    os.write(fontCharset);
+                    writeInt(os, 0);
+                    os.write(delimiter);
+                    os.write(fontTimesNewRoman);
+                    break;
+                case Font.ZAPFDINGBATS:
+                    os.write(fontTech);
+                    os.write(escape);
+                    os.write(fontCharset);
+                    writeInt(os, 0);
+                    os.write(delimiter);
+                    os.write(fontWindings);
+                    break;
+                default:
+                    os.write(fontRoman);
+                    os.write(escape);
+                    os.write(fontCharset);
+                    writeInt(os, 0);
+                    os.write(delimiter);
+                    os.write(filterSpecialChar(fnt.getFamilyname(), true).getBytes());
+            }
+            os.write(commaDelimiter);
+            os.write(closeGroup);
+        }
+        os.write(closeGroup);
+    }
+
+    /**
+     * Write the colour list to the final <code>ByteArrayOutputStream</code>
+     * @throws IOException
+     */
+    private void writeColorList() throws IOException {
+        Color color = null;
+
+        os.write(openGroup);
+        os.write(escape);
+        os.write(colorTable);
+        for (int i = 0; i < colorList.size(); i++) {
+            color = (Color) colorList.get(i);
+            os.write(escape);
+            os.write(colorRed);
+            writeInt(os, color.getRed());
+            os.write(escape);
+            os.write(colorGreen);
+            writeInt(os, color.getGreen());
+            os.write(escape);
+            os.write(colorBlue);
+            writeInt(os, color.getBlue());
+            os.write(commaDelimiter);
+        }
+        os.write(closeGroup);
+    }
+
+    /**
+     * Write the Information Group to the final <code>ByteArrayOutputStream</code>
+     * @throws IOException
+     */
+    private void writeInfoGroup() throws IOException {
+        os.write(openGroup);
+        os.write(escape);
+        os.write(infoBegin);
+        info.writeTo(os);
+        os.write(closeGroup);
+    }
+
+    /**
+     * Write the listtable and listoverridetable to the final <code>ByteArrayOutputStream</code>
+     * @throws IOException
+     */
+    private void writeList() throws IOException {
+        listtable.write(closeGroup);
+        listoverride.write(closeGroup);
+        listtable.writeTo(os);
+        os.write((byte) '\n');
+        listoverride.writeTo(os);
+    }
+
+    /**
+     * Write an integer
+     *
+     * @param out The <code>OuputStream</code> to which the <code>int</code> value is to be written
+     * @param i The <code>int</code> value to be written
+     * @throws IOException
+     */
+    public final static void writeInt(OutputStream out, int i) throws IOException {
+        out.write(Integer.toString(i).getBytes());
+    }
+
+    /**
+     * Get a random integer.
+     * This returns a <b>unique</b> random integer to be used with listids.
+     *
+     * @return Random <code>int</code> value.
+     */
+    private int getRandomInt() {
+        boolean ok = false;
+        Integer newInt = null;
+        Integer oldInt = null;
+        while (!ok) {
+            newInt = new Integer((int) (Math.random() * Integer.MAX_VALUE));
+            ok = true;
+            for (int i = 0; i < listIds.size(); i++) {
+                oldInt = (Integer) listIds.get(i);
+                if (oldInt.equals(newInt)) {
+                    ok = true;
+                }
+            }
+        }
+        listIds.add(newInt);
+        return newInt.intValue();
+    }
+
+    /**
+     * Write the current header and footer to a <code>ByteArrayOutputStream</code>
+     *
+     * @param os		The <code>ByteArrayOutputStream</code> to which the header and footer will be written.
+     * @throws IOException
+     */
+    public void writeHeadersFooters(ByteArrayOutputStream os) throws IOException {
+        if (this.footer instanceof RtfHeaderFooters) {
+            RtfHeaderFooters rtfHf = (RtfHeaderFooters) this.footer;
+            HeaderFooter hf = rtfHf.get(RtfHeaderFooters.ALL_PAGES);
+            if (hf != null) {
+                writeHeaderFooter(hf, footerBegin, os);
+            }
+            hf = rtfHf.get(RtfHeaderFooters.LEFT_PAGES);
+            if (hf != null) {
+                writeHeaderFooter(hf, footerlBegin, os);
+            }
+            hf = rtfHf.get(RtfHeaderFooters.RIGHT_PAGES);
+            if (hf != null) {
+                writeHeaderFooter(hf, footerrBegin, os);
+            }
+            hf = rtfHf.get(RtfHeaderFooters.FIRST_PAGE);
+            if (hf != null) {
+                writeHeaderFooter(hf, footerfBegin, os);
+            }
+        } else {
+            writeHeaderFooter(this.footer, footerBegin, os);
+        }
+        if (this.header instanceof RtfHeaderFooters) {
+            RtfHeaderFooters rtfHf = (RtfHeaderFooters) this.header;
+            HeaderFooter hf = rtfHf.get(RtfHeaderFooters.ALL_PAGES);
+            if (hf != null) {
+                writeHeaderFooter(hf, headerBegin, os);
+            }
+            hf = rtfHf.get(RtfHeaderFooters.LEFT_PAGES);
+            if (hf != null) {
+                writeHeaderFooter(hf, headerlBegin, os);
+            }
+            hf = rtfHf.get(RtfHeaderFooters.RIGHT_PAGES);
+            if (hf != null) {
+                writeHeaderFooter(hf, headerrBegin, os);
+            }
+            hf = rtfHf.get(RtfHeaderFooters.FIRST_PAGE);
+            if (hf != null) {
+                writeHeaderFooter(hf, headerfBegin, os);
+            }
+        } else {
+            writeHeaderFooter(this.header, headerBegin, os);
+        }
+    }
+
+    /**
+     * Write a <code>HeaderFooter</code> to a <code>ByteArrayOutputStream</code>
+     *
+     * @param headerFooter	The <code>HeaderFooter</code> object to be written.
+     * @param hfType		The type of header or footer to be added.
+     * @param target		The <code>ByteArrayOutputStream</code> to which the <code>HeaderFooter</code> will be written.
+     * @throws IOException
+     */
+    private void writeHeaderFooter(HeaderFooter headerFooter, byte[] hfType, ByteArrayOutputStream target) throws IOException {
+        inHeaderFooter = true;
+        try {
+            target.write(openGroup);
+            target.write(escape);
+            target.write(hfType);
+            target.write(delimiter);
+            if (headerFooter != null) {
+                if (headerFooter instanceof RtfHeaderFooter && ((RtfHeaderFooter) headerFooter).content() != null) {
+                    this.addElement(((RtfHeaderFooter) headerFooter).content(), target);
+                } else {
+                    Paragraph par = new Paragraph();
+                    par.setAlignment(headerFooter.alignment());
+                    if (headerFooter.getBefore() != null) {
+                        par.add(headerFooter.getBefore());
+                    }
+                    if (headerFooter.isNumbered()) {
+                        par.add(new RtfPageNumber("", headerFooter.getBefore().getFont()));
+                    }
+                    if (headerFooter.getAfter() != null) {
+                        par.add(headerFooter.getAfter());
+                    }
+                    this.addElement(par, target);
+                }
+            }
+            target.write(closeGroup);
+        } catch (DocumentException e) {
+            throw new IOException("DocumentException - " + e.getMessage());
+        }
+        inHeaderFooter = false;
+    }
+
+    /**
+     *  Write the <code>Document</code>'s Paper and Margin Size
+     *  to the final <code>ByteArrayOutputStream</code>
+     * @throws IOException
+     */
+    private void writeDocumentFormat() throws IOException {
+//        os.write(openGroup);
+        os.write(escape);
+        os.write(rtfPaperWidth);
+        writeInt(os, pageWidth);
+        os.write(escape);
+        os.write(rtfPaperHeight);
+        writeInt(os, pageHeight);
+        os.write(escape);
+        os.write(rtfMarginLeft);
+        writeInt(os, marginLeft);
+        os.write(escape);
+        os.write(rtfMarginRight);
+        writeInt(os, marginRight);
+        os.write(escape);
+        os.write(rtfMarginTop);
+        writeInt(os, marginTop);
+        os.write(escape);
+        os.write(rtfMarginBottom);
+        writeInt(os, marginBottom);
+//        os.write(closeGroup);
+    }
+
+    /**
+     * Initialise all helper classes.
+     * Clears alls lists, creates new <code>ByteArrayOutputStream</code>'s
+     */
+    private void initDefaults() {
+        fontList.clear();
+        colorList.clear();
+        info = new ByteArrayOutputStream();
+        content = new ByteArrayOutputStream();
+        listtable = new ByteArrayOutputStream();
+        listoverride = new ByteArrayOutputStream();
+        document.addProducer();
+        document.addCreationDate();
+        addFont(new Font(Font.TIMES_ROMAN, 10, Font.NORMAL));
+        addColor(new Color(0, 0, 0));
+        addColor(new Color(255, 255, 255));
+        listIds = new ArrayList();
+        try {
+            listtable.write(openGroup);
+            listtable.write(extendedEscape);
+            listtable.write(listtableGroup);
+            listtable.write((byte) '\n');
+            listoverride.write(openGroup);
+            listoverride.write(extendedEscape);
+            listoverride.write(listoverridetableGroup);
+            listoverride.write((byte) '\n');
+        } catch (IOException e) {
+            System.err.println("InitDefaultsError" + e);
+        }
+    }
+
+    /**
+     * Writes the default values for the current Section
+     *
+     * @param out The <code>ByteArrayOutputStream</code> to be written to
+     * @throws IOException
+     */
+    private void writeSectionDefaults(ByteArrayOutputStream out) throws IOException {
+        if (header instanceof RtfHeaderFooters || footer instanceof RtfHeaderFooters) {
+            RtfHeaderFooters rtfHeader = (RtfHeaderFooters) header;
+            RtfHeaderFooters rtfFooter = (RtfHeaderFooters) footer;
+            if ((rtfHeader != null && (rtfHeader.get(RtfHeaderFooters.LEFT_PAGES) != null || rtfHeader.get(RtfHeaderFooters.RIGHT_PAGES) != null)) || (rtfFooter != null && (rtfFooter.get(RtfHeaderFooters.LEFT_PAGES) != null || rtfFooter.get(RtfHeaderFooters.RIGHT_PAGES) != null))) {
+                out.write(escape);
+                out.write(facingPages);
+            }
+        }
+        if (hasTitlePage) {
+            out.write(escape);
+            out.write(titlePage);
+        }
+        writeHeadersFooters(out);
+        if (landscape) {
+            //out.write(escape);
+            //out.write(landscapeTag1);
+            out.write(escape);
+            out.write(landscapeTag2);
+            out.write(escape);
+            out.write(sectionPageWidth);
+            writeInt(out, pageWidth);
+            out.write(escape);
+            out.write(sectionPageHeight);
+            writeInt(out, pageHeight);
+        } else {
+            out.write(escape);
+            out.write(sectionPageWidth);
+            writeInt(out, pageWidth);
+            out.write(escape);
+            out.write(sectionPageHeight);
+            writeInt(out, pageHeight);
+        }
+    }
+
+    /**
+     * This method tries to fit the <code>Rectangle pageSize</code> to one of the predefined PageSize rectangles.
+     * If a match is found the pageWidth and pageHeight will be set according to values determined from files
+     * generated by MS Word2000 and OpenOffice 641. If no match is found the method will try to match the rotated
+     * Rectangle by calling itself with the parameter rotate set to true.
+     * @param pageSize a rectangle defining the size of the page
+     * @param rotate portrait or lanscape?
+     * @return true if the format parsing succeeded
+     */
+    private boolean parseFormat(Rectangle pageSize, boolean rotate) {
+        if (rotate) {
+            pageSize = pageSize.rotate();
+        }
+        if (rectEquals(pageSize, PageSize.A3)) {
+            pageWidth = 16837;
+            pageHeight = 23811;
+            landscape = rotate;
+            return true;
+        }
+        if (rectEquals(pageSize, PageSize.A4)) {
+            pageWidth = 11907;
+            pageHeight = 16840;
+            landscape = rotate;
+            return true;
+        }
+        if (rectEquals(pageSize, PageSize.A5)) {
+            pageWidth = 8391;
+            pageHeight = 11907;
+            landscape = rotate;
+            return true;
+        }
+        if (rectEquals(pageSize, PageSize.A6)) {
+            pageWidth = 5959;
+            pageHeight = 8420;
+            landscape = rotate;
+            return true;
+        }
+        if (rectEquals(pageSize, PageSize.B4)) {
+            pageWidth = 14570;
+            pageHeight = 20636;
+            landscape = rotate;
+            return true;
+        }
+        if (rectEquals(pageSize, PageSize.B5)) {
+            pageWidth = 10319;
+            pageHeight = 14572;
+            landscape = rotate;
+            return true;
+        }
+        if (rectEquals(pageSize, PageSize.HALFLETTER)) {
+            pageWidth = 7927;
+            pageHeight = 12247;
+            landscape = rotate;
+            return true;
+        }
+        if (rectEquals(pageSize, PageSize.LETTER)) {
+            pageWidth = 12242;
+            pageHeight = 15842;
+            landscape = rotate;
+            return true;
+        }
+        if (rectEquals(pageSize, PageSize.LEGAL)) {
+            pageWidth = 12252;
+            pageHeight = 20163;
+            landscape = rotate;
+            return true;
+        }
+        if (!rotate && parseFormat(pageSize, true)) {
+            int x = pageWidth;
+            pageWidth = pageHeight;
+            pageHeight = x;
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * This method compares to Rectangles. They are considered equal if width and height are the same
+     * @param rect1
+     * @param rect2
+     * @return true if rect1 and rect2 represent the same rectangle
+     */
+    private boolean rectEquals(Rectangle rect1, Rectangle rect2) {
+        return (rect1.getWidth() == rect2.getWidth()) && (rect1.getHeight() == rect2.getHeight());
+    }
+
+    /**
+     * Returns whether we are currently writing a header or footer
+     *
+     * @return the value of inHeaderFooter
+     */
+    public boolean writingHeaderFooter() {
+        return inHeaderFooter;
+    }
+
+    /**
+     * Replaces special characters with their unicode values
+     *
+     * @param str The original <code>String</code>
+     * @param useHex
+     * @return The converted String
+     */
+    public final static String filterSpecialChar(String str, boolean useHex) {
+        int length = str.length();
+        int z = (int) 'z';
+        StringBuffer ret = new StringBuffer(length);
+        for (int i = 0; i < length; i++) {
+            char ch = str.charAt(i);
+
+            if (ch == '\\') {
+                ret.append("\\\\");
+            } else if (ch == '\n') {
+                ret.append("\\par ");
+            } else if (((int) ch) > z) {
+                if(useHex) {
+                    ret.append("\\\'").append(Long.toHexString((long) ch));
+                } else {
+                ret.append("\\u").append((long) ch).append('?');
+                }
+            } else {
+                ret.append(ch);
+            }
+        }
+        String s = ret.toString();
+        if(s.indexOf("$newpage$") >= 0) {
+            String before = s.substring(0, s.indexOf("$newpage$"));
+            String after = s.substring(s.indexOf("$newpage$") + 9);
+            ret = new StringBuffer(before);
+            ret.append("\\page\\par ");
+            ret.append(after);
+            return ret.toString();
+        }
+        return s;
+    }
+
+    private void addHeaderFooterFontColor(HeaderFooter hf) {
+        if(hf instanceof RtfHeaderFooter) {
+            RtfHeaderFooter rhf = (RtfHeaderFooter) hf;
+            if(rhf.content() instanceof Chunk) {
+                addFont(((Chunk) rhf.content()).getFont());
+                addColor(((Chunk) rhf.content()).getFont().getColor());
+            } else if(rhf.content() instanceof Phrase) {
+                addFont(((Phrase) rhf.content()).getFont());
+                addColor(((Phrase) rhf.content()).getFont().getColor());
+            }
+        }
+        if(hf.getBefore() != null) {
+            addFont(hf.getBefore().getFont());
+            addColor(hf.getBefore().getFont().getColor());
+        }
+        if(hf.getAfter() != null) {
+            addFont(hf.getAfter().getFont());
+            addColor(hf.getAfter().getFont().getColor());
+        }
+    }
+
+    private void processHeaderFooter(HeaderFooter hf) {
+        if(hf != null) {
+            if(hf instanceof RtfHeaderFooters) {
+                RtfHeaderFooters rhf = (RtfHeaderFooters) hf;
+                if(rhf.get(RtfHeaderFooters.ALL_PAGES) != null) {
+                    addHeaderFooterFontColor(rhf.get(RtfHeaderFooters.ALL_PAGES));
+                }
+                if(rhf.get(RtfHeaderFooters.LEFT_PAGES) != null) {
+                    addHeaderFooterFontColor(rhf.get(RtfHeaderFooters.LEFT_PAGES));
+                }
+                if(rhf.get(RtfHeaderFooters.RIGHT_PAGES) != null) {
+                    addHeaderFooterFontColor(rhf.get(RtfHeaderFooters.RIGHT_PAGES));
+                }
+                if(rhf.get(RtfHeaderFooters.FIRST_PAGE) != null) {
+                    addHeaderFooterFontColor(rhf.get(RtfHeaderFooters.FIRST_PAGE));
+                }
+            } else {
+                addHeaderFooterFontColor(hf);
+            }
+        }
+    }
+
+    /**
+     * @see com.lowagie.text.DocListener#setMarginMirroring(boolean)
+     */
+    public boolean setMarginMirroring(boolean MarginMirroring) {
+        return false;
+    }
+
+}
+
Index: src/core/com/lowagie/text/rtf/AbstractRtfField.java
===================================================================
--- src/core/com/lowagie/text/rtf/AbstractRtfField.java	(revision 0)
+++ src/core/com/lowagie/text/rtf/AbstractRtfField.java	(revision 0)
@@ -0,0 +1,358 @@
+/**
+ * $Id$
+ *
+ * Copyright 2002 by 
+ * <a href="http://www.smb-tec.com">SMB</a> 
+ * <a href="mailto:Dirk.Weigenand@smb-tec.com">Dirk.Weigenand@smb-tec.com</a>
+ *
+ * The contents of this file are subject to the Mozilla Public License Version 1.1
+ * (the "License"); you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the License.
+ *
+ * The Original Code is 'iText, a free JAVA-PDF library'.
+ *
+ * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
+ * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
+ * All Rights Reserved.
+ * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
+ * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
+ *
+ * Contributor(s): all the names of the contributors are added in the source code
+ * where applicable.
+ *
+ * Alternatively, the contents of this file may be used under the terms of the
+ * LGPL license (the GNU LIBRARY GENERAL PUBLIC LICENSE), in which case the
+ * provisions of LGPL are applicable instead of those above.  If you wish to
+ * allow use of your version of this file only under the terms of the LGPL
+ * License and not to allow others to use your version of this file under
+ * the MPL, indicate your decision by deleting the provisions above and
+ * replace them with the notice and other provisions required by the LGPL.
+ * If you do not delete the provisions above, a recipient may use your version
+ * of this file under either the MPL or the GNU LIBRARY GENERAL PUBLIC LICENSE.
+
+ *
+ * This library is free software; you can redistribute it and/or modify it
+ * under the terms of the MPL as stated above or under the terms of the GNU
+ * Library General Public License as published by the Free Software Foundation;
+ * either version 2 of the License, or any later version.
+ *
+ * This library is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU Library general Public License for more
+ * details.
+ *
+ * If you didn't download this code from the following link, you should check if
+ * you aren't using an obsolete version:
+ * http://www.lowagie.com/iText/
+ */
+
+package com.lowagie.text.rtf;
+
+import com.lowagie.text.Chunk;
+import com.lowagie.text.Font;
+import com.lowagie.text.rtf.RtfWriter;
+
+import java.io.OutputStream;
+import java.io.IOException;
+
+
+/**
+ * This class implements an abstract RtfField.
+ *
+ * This class is based on the RtfWriter-package from Mark Hall.
+ * 
+ * ONLY FOR USE WITH THE RtfWriter NOT with the RtfWriter2.
+ *
+ * @author <a href="mailto:Dirk.Weigenand@smb-tec.com">Dirk Weigenand</a>
+ * @version $Id$
+ * @since Mon Aug 19 14:50:39 2002
+ * @deprecated Please move to the RtfWriter2 and associated classes.
+ */
+abstract class AbstractRtfField extends Chunk implements RtfField {
+    private static final byte[] fldDirty = "\\flddirty".getBytes();
+    private static final byte[] fldPriv = "\\fldpriv".getBytes();
+    private static final byte[] fldLock = "\\fldlock".getBytes();
+    private static final byte[] fldEdit = "\\fldedit".getBytes();
+    private static final byte[] fldAlt = "\\fldalt".getBytes();
+
+    /**
+     * public constructor
+     * @param content the content of the field
+     * @param font the font of the field
+     */
+    public AbstractRtfField(String content, Font font) {
+        super(content, font);
+    }
+
+    /**
+     * Determines whether this RtfField is locked, i.e. it cannot be
+     * updated. Defaults to <tt>false</tt>.
+     */
+    private boolean rtfFieldIsLocked = false;
+
+    /**
+     * Determines whether a formatting change has been made since the
+     * field was last updated. Defaults to <tt>false</tt>.
+     */
+    private boolean rtfFieldIsDirty = false;
+
+    /**
+     * Determines whether text has been added, removed from thre field
+     * result since the field was last updated. Defaults to
+     * <tt>false</tt>.
+     */
+    private boolean rtfFieldWasEdited = false;
+
+    /**
+     * Determines whether the field is in suitable form for
+     * display. Defaults to <tt>false</tt>.
+     */
+    private boolean rtfFieldIsPrivate = false;
+
+    /**
+     * Determines whether this RtfField shall refer to an end note.
+     */
+    private boolean rtfFieldIsAlt = false;
+
+    /**
+     * Determines whtether the field is locked, i.e. it cannot be
+     * updated.
+     * 
+     * @return <tt>true</tt> iff the field cannot be updated,
+     * <tt>false</tt> otherwise.
+     */
+    public final boolean isLocked() {
+        return this.rtfFieldIsLocked;
+    }
+
+    /**
+     * Set whether the field can be updated.
+     *
+     * @param rtfFieldIsLocked <tt>true</tt> if the field cannot be
+     * updated, <tt>false</tt> otherwise.
+     */
+    public final void setLocked(final boolean rtfFieldIsLocked) {
+        this.rtfFieldIsLocked = rtfFieldIsLocked;
+    }
+
+    /**
+     * Set whether a formatting change has been made since the field
+     * was last updated
+     * @param rtfFieldIsDirty <tt>true</tt> if the field was
+     * changed since the field was last updated, <tt>false</tt>
+     * otherwise.
+     */
+    public final void setDirty(final boolean rtfFieldIsDirty) {
+        this.rtfFieldIsDirty = rtfFieldIsDirty;
+    }
+
+    /**
+     * Determines whether the field was changed since the field was
+     * last updated
+     * @return <tt>true</tt> if the field was changed since the field
+     * was last updated, <tt>false</tt> otherwise.
+     */
+    public final boolean isDirty() {
+        return this.rtfFieldIsDirty;
+    }
+
+    /**
+     * Set whether text has been added, removed from thre field result
+     * since the field was last updated.
+     * @param rtfFieldWasEdited Determines whether text has been
+     * added, removed from the field result since the field was last
+     * updated (<tt>true</tt>, <tt>false</tt> otherwise..
+     */
+    public final void setEdited(final boolean rtfFieldWasEdited) {
+        this.rtfFieldWasEdited = rtfFieldWasEdited;
+    }
+
+    /**
+     * Determines whether text has been added, removed from the field
+     * result since the field was last updated.
+     * @return rtfFieldWasEdited <tt>true</tt> if text has been added,
+     * removed from the field result since the field was last updated,
+     * <tt>false</tt> otherwise.
+     */
+    public final boolean wasEdited() {
+        return this.rtfFieldWasEdited;
+    }
+
+    /**
+     * Set whether the field is in suitable form for
+     * display. I.e. it's not a field with a picture as field result
+     * @param rtfFieldIsPrivate Determines whether the field is in
+     * suitable form for display: <tt>true</tt> it can be displayed,
+     * <tt>false</tt> it cannot be displayed.
+     */
+    public final void setPrivate(final boolean rtfFieldIsPrivate) {
+        this.rtfFieldIsPrivate = rtfFieldIsPrivate;
+    }
+
+    /**
+     * Determines whether the field is in suitable form for display.
+     * @return whether the field is in suitable form for display:
+     * <tt>true</tt> yes, <tt>false</tt> no it cannot be displayed.
+     */
+    public final boolean isPrivate() {
+        return this.rtfFieldIsPrivate;
+    }
+
+    /**
+     * Abstract method for writing custom stuff to the Field
+     * Initialization Stuff part of an RtfField.
+     * @param out
+     * @throws IOException
+     */
+    public abstract void writeRtfFieldInitializationStuff(OutputStream out) throws IOException;
+
+    /**
+     * Abstract method for writing custom stuff to the Field Result
+     * part of an RtfField.
+     * @param out
+     * @throws IOException
+     */
+    public abstract void writeRtfFieldResultStuff(OutputStream out) throws IOException;
+
+    /**
+     * Determines whether this RtfField shall refer to an end note.
+     * @param rtfFieldIsAlt <tt>true</tt> if this RtfField shall refer
+     * to an end note, <tt>false</tt> otherwise
+     */
+    public final void setAlt(final boolean rtfFieldIsAlt) {
+        this.rtfFieldIsAlt = rtfFieldIsAlt;
+    }
+
+    /**
+     * Determines whether this RtfField shall refer to an end
+     * note.
+     * @return <tt>true</tt> if this RtfField shall refer to an end
+     * note, <tt>false</tt> otherwise.
+     */
+    public final boolean isAlt() {
+        return this.rtfFieldIsAlt;
+    }
+
+    /**
+     * empty implementation for Chunk.
+     * @return an empty string
+     */
+    public final String content() {
+        return "";
+    }
+
+    /**
+     * For Interface RtfField.
+     * @param writer
+     * @param out
+     * @throws IOException
+     */
+    public void write( RtfWriter writer, OutputStream out ) throws IOException {
+        writeRtfFieldBegin(out);
+        writeRtfFieldModifiers(out);
+        writeRtfFieldInstBegin(out);
+        writer.writeInitialFontSignature( out, this );
+        writeRtfFieldInitializationStuff(out);
+        writeRtfFieldInstEnd(out);
+        writeRtfFieldResultBegin(out);
+        writer.writeInitialFontSignature( out, this );
+        writeRtfFieldResultStuff(out);
+        writeRtfFieldResultEnd(out);
+        writeRtfFieldEnd(out);
+    }
+
+    /**
+     * Write the beginning of an RtfField to the OutputStream.
+     * @param out
+     * @throws IOException
+     */
+    protected final void writeRtfFieldBegin(OutputStream out)  throws IOException {
+        out.write(RtfWriter.openGroup);
+        out.write(RtfWriter.escape);
+        out.write(RtfWriter.field);
+    }
+
+    /**
+     * Write the modifiers defined for a RtfField to the OutputStream.
+     * @param out
+     * @throws IOException
+     */
+    protected final void writeRtfFieldModifiers(OutputStream out) throws IOException {
+        if (isDirty()) {
+            out.write(fldDirty);
+        }
+
+        if (wasEdited()) {
+            out.write(fldEdit);
+        }
+
+        if (isLocked()) {
+            out.write(fldLock);
+        }
+
+        if (isPrivate()) {
+            out.write(fldPriv);
+        }
+    }
+
+    /**
+     * Write RtfField Initialization Stuff to OutputStream.
+     * @param out
+     * @throws IOException
+     */
+    protected final void writeRtfFieldInstBegin(OutputStream out) throws IOException {
+        out.write( RtfWriter.openGroup );        
+        out.write( RtfWriter.escape );
+        out.write( RtfWriter.fieldContent );
+        out.write( RtfWriter.delimiter );
+    }
+
+    /**
+     * Write end of RtfField Initialization Stuff to OutputStream.
+     * @param out
+     * @throws IOException
+     */
+    protected final void writeRtfFieldInstEnd(OutputStream out) throws IOException {
+        if (isAlt()) {
+            out.write( fldAlt );
+            out.write( RtfWriter.delimiter );
+        }
+
+        out.write( RtfWriter.closeGroup );
+    }
+
+    /**
+     * Write beginning of RtfField Result to OutputStream.
+     * @param out
+     * @throws IOException
+     */
+    protected final void writeRtfFieldResultBegin(OutputStream out) throws IOException {
+        out.write( RtfWriter.openGroup );        
+        out.write( RtfWriter.escape );
+        out.write( RtfWriter.fieldDisplay );
+        out.write( RtfWriter.delimiter );
+    }
+
+    /**
+     * Write end of RtfField Result to OutputStream.
+     * @param out
+     * @throws IOException
+     */
+    protected final void writeRtfFieldResultEnd(OutputStream out) throws IOException {
+        out.write( RtfWriter.delimiter );
+        out.write( RtfWriter.closeGroup );
+    }
+
+    /**
+     * Close the RtfField.
+     * @param out
+     * @throws IOException
+     */
+    protected final void writeRtfFieldEnd(OutputStream out) throws IOException {
+        out.write( RtfWriter.closeGroup );
+    }
+}
Index: src/core/com/lowagie/text/rtf/RtfCell.java
===================================================================
--- src/core/com/lowagie/text/rtf/RtfCell.java	(revision 0)
+++ src/core/com/lowagie/text/rtf/RtfCell.java	(revision 0)
@@ -0,0 +1,549 @@
+/**
+ * $Id$
+ * $Name$
+ *
+ * Copyright 2001, 2002 by Mark Hall
+ *
+ * The contents of this file are subject to the Mozilla Public License Version 1.1
+ * (the "License"); you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the License.
+ *
+ * The Original Code is 'iText, a free JAVA-PDF library'.
+ *
+ * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
+ * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
+ * All Rights Reserved.
+ * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
+ * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
+ *
+ * Contributor(s): all the names of the contributors are added in the source code
+ * where applicable.
+ *
+ * Alternatively, the contents of this file may be used under the terms of the
+ * LGPL license (the ?GNU LIBRARY GENERAL PUBLIC LICENSE?), in which case the
+ * provisions of LGPL are applicable instead of those above.  If you wish to
+ * allow use of your version of this file only under the terms of the LGPL
+ * License and not to allow others to use your version of this file under
+ * the MPL, indicate your decision by deleting the provisions above and
+ * replace them with the notice and other provisions required by the LGPL.
+ * If you do not delete the provisions above, a recipient may use your version
+ * of this file under either the MPL or the GNU LIBRARY GENERAL PUBLIC LICENSE.
+ *
+ * This library is free software; you can redistribute it and/or modify it
+ * under the terms of the MPL as stated above or under the terms of the GNU
+ * Library General Public License as published by the Free Software Foundation;
+ * either version 2 of the License, or any later version.
+ *
+ * This library is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU Library general Public License for more
+ * details.
+ *
+ * If you didn't download this code from the following link, you should check if
+ * you aren't using an obsolete version:
+ * http://www.lowagie.com/iText/
+ */
+
+package com.lowagie.text.rtf;
+
+import com.lowagie.text.*;
+
+import java.util.Iterator;
+import java.io.*;
+import java.awt.Color;
+
+/**
+ * A Helper Class for the <CODE>RtfWriter</CODE>.
+ * <P>
+ * Do not use it directly
+ *
+ * ONLY FOR USE WITH THE RtfWriter NOT with the RtfWriter2.
+ *
+ * Parts of this Class were contributed by Steffen Stundzig. Many thanks for the
+ * improvements.
+ * Updates by Benoit WIART <b.wiart@proxiad.com>
+ * @deprecated Please move to the RtfWriter2 and associated classes.
+ */
+public class RtfCell {
+    /** Constants for merging Cells */
+
+    /** A possible value for merging */
+    private static final int MERGE_HORIZ_FIRST = 1;
+    /** A possible value for merging */
+    private static final int MERGE_VERT_FIRST = 2;
+    /** A possible value for merging */
+    private static final int MERGE_BOTH_FIRST = 3;
+    /** A possible value for merging */
+    private static final int MERGE_HORIZ_PREV = 4;
+    /** A possible value for merging */
+    private static final int MERGE_VERT_PREV = 5;
+    /** A possible value for merging */
+    private static final int MERGE_BOTH_PREV = 6;
+
+    /**
+     * RTF Tags
+     */
+
+    /** First cell to merge with - Horizontal */
+    private static final byte[] cellMergeFirst = "clmgf".getBytes();
+    /** First cell to merge with - Vertical */
+    private static final byte[] cellVMergeFirst = "clvmgf".getBytes();
+    /** Merge cell with previous horizontal cell */
+    private static final byte[] cellMergePrev = "clmrg".getBytes();
+    /** Merge cell with previous vertical cell */
+    private static final byte[] cellVMergePrev = "clvmrg".getBytes();
+    /** Cell content vertical alignment bottom */
+    private static final byte[] cellVerticalAlignBottom = "clvertalb".getBytes();
+    /** Cell content vertical alignment center */
+    private static final byte[] cellVerticalAlignCenter = "clvertalc".getBytes();
+    /** Cell content vertical alignment top */
+    private static final byte[] cellVerticalAlignTop = "clvertalt".getBytes();
+    /** Cell border left */
+    private static final byte[] cellBorderLeft = "clbrdrl".getBytes();
+    /** Cell border right */
+    private static final byte[] cellBorderRight = "clbrdrr".getBytes();
+    /** Cell border top */
+    private static final byte[] cellBorderTop = "clbrdrt".getBytes();
+    /** Cell border bottom */
+    private static final byte[] cellBorderBottom = "clbrdrb".getBytes();
+    /** Cell background color */
+    private static final byte[] cellBackgroundColor = "clcbpat".getBytes();
+    /** Cell width format */
+    private static final byte[] cellWidthStyle = "clftsWidth3".getBytes();
+    /** Cell width */
+    private static final byte[] cellWidthTag = "clwWidth".getBytes();
+    /** Cell right border position */
+    private static final byte[] cellRightBorder = "cellx".getBytes();
+    /** Cell is part of table */
+    protected static final byte[] cellInTable = "intbl".getBytes();
+    /** End of cell */
+    private static final byte[] cellEnd = "cell".getBytes();
+
+    /** padding top */
+    private static final byte[] cellPaddingTop = "clpadt".getBytes();
+    /** padding top unit */
+    private static final byte[] cellPaddingTopUnit = "clpadft3".getBytes();
+    /** padding bottom */
+    private static final byte[] cellPaddingBottom = "clpadb".getBytes();
+    /** padding bottom unit */
+    private static final byte[] cellPaddingBottomUnit = "clpadfb3".getBytes();
+    /** padding left */
+    private static final byte[] cellPaddingLeft = "clpadl".getBytes();
+    /** padding left unit */
+    private static final byte[] cellPaddingLeftUnit = "clpadfl3".getBytes();
+    /** padding right */
+    private static final byte[] cellPaddingRight = "clpadr".getBytes();
+    /** padding right unit */
+    private static final byte[] cellPaddingRightUnit = "clpadfr3".getBytes();
+
+    /** The <code>RtfWriter</code> to which this <code>RtfCell</code> belongs. */
+    private RtfWriter writer = null;
+    /** The <code>RtfTable</code> to which this <code>RtfCell</code> belongs. */
+    private RtfTable mainTable = null;
+
+    /** Cell width */
+    private int cellWidth = 0;
+    /** Cell right border position */
+    private int cellRight = 0;
+    /** <code>Cell</code> containing the actual data */
+    private Cell store = null;
+    /** Is this an empty cell */
+    private boolean emptyCell = true;
+    /** Type of merging to do */
+    private int mergeType = 0;
+    /** cell padding, because the table only renders the left and right cell padding
+     * and not the top and bottom one
+     */
+    private int cellpadding = 0;
+
+    /**
+     * Create a new <code>RtfCell</code>.
+     *
+     * @param writer The <code>RtfWriter</code> that this <code>RtfCell</code> belongs to
+     * @param mainTable The <code>RtfTable</code> that created the
+     * <code>RtfRow</code> that created the <code>RtfCell</code> :-)
+     */
+    public RtfCell(RtfWriter writer, RtfTable mainTable) {
+        super();
+        this.writer = writer;
+        this.mainTable = mainTable;
+    }
+
+    /**
+     * Import a <code>Cell</code>.
+     * <P>
+     * @param cell The <code>Cell</code> containing the data for this
+     * <code>RtfCell</code>
+     * @param cellLeft The position of the left border
+     * @param cellWidth The default width of a cell
+     * @param x The column index of this <code>RtfCell</code>
+     * @param y The row index of this <code>RtfCell</code>
+     * @param cellpadding the cellpadding
+     * @return the position of the right side of the cell
+     */
+    public int importCell(Cell cell, int cellLeft, int cellWidth, int x, int y, int cellpadding) {
+        this.cellpadding = cellpadding;
+
+        // set this value in any case
+        this.cellWidth = cellWidth;
+        if (cell == null) {
+            cellRight = cellLeft + cellWidth;
+            return cellRight;
+        }
+        if (cell.getWidthAsString() != null && !cell.getWidthAsString().equals("")) {
+
+            this.cellWidth = (int) (Integer.parseInt(cell.getWidthAsString()) * RtfWriter.TWIPSFACTOR);
+        }
+        cellRight = cellLeft + this.cellWidth;
+        store = cell;
+        emptyCell = false;
+        if (cell.getColspan() > 1) {
+            if (cell.getRowspan() > 1) {
+                mergeType = MERGE_BOTH_FIRST;
+                for (int i = y; i < y + cell.getRowspan(); i++) {
+                    if (i > y) mainTable.setMerge(x, i, MERGE_VERT_PREV, this);
+                    for (int j = x + 1; j < x + cell.getColspan(); j++) {
+                        mainTable.setMerge(j, i, MERGE_BOTH_PREV, this);
+                    }
+                }
+            } else {
+                mergeType = MERGE_HORIZ_FIRST;
+                for (int i = x + 1; i < x + cell.getColspan(); i++) {
+                    mainTable.setMerge(i, y, MERGE_HORIZ_PREV, this);
+                }
+            }
+        } else if (cell.getRowspan() > 1) {
+            mergeType = MERGE_VERT_FIRST;
+            for (int i = y + 1; i < y + cell.getRowspan(); i++) {
+                mainTable.setMerge(x, i, MERGE_VERT_PREV, this);
+            }
+        }
+        return cellRight;
+    }
+
+    /**
+     * Write the properties of the <code>RtfCell</code>.
+     *
+     * @param os The <code>OutputStream</code> to which to write the properties
+     * of the <code>RtfCell</code> to.
+     * @return true if writing the cell settings succeeded
+     * @throws DocumentException
+     */
+    public boolean writeCellSettings(ByteArrayOutputStream os) throws DocumentException {
+        try {
+            float lWidth, tWidth, rWidth, bWidth;
+            byte[] lStyle, tStyle, rStyle, bStyle;
+
+            if (store instanceof RtfTableCell) {
+                RtfTableCell c = (RtfTableCell) store;
+                lWidth = c.leftBorderWidth();
+                tWidth = c.topBorderWidth();
+                rWidth = c.rightBorderWidth();
+                bWidth = c.bottomBorderWidth();
+                lStyle = RtfTableCell.getStyleControlWord(c.leftBorderStyle());
+                tStyle = RtfTableCell.getStyleControlWord(c.topBorderStyle());
+                rStyle = RtfTableCell.getStyleControlWord(c.rightBorderStyle());
+                bStyle = RtfTableCell.getStyleControlWord(c.bottomBorderStyle());
+            } else {
+                lWidth = tWidth = rWidth = bWidth = store.getBorderWidth();
+                lStyle = tStyle = rStyle = bStyle = RtfRow.tableBorder;
+            }
+
+            if (mergeType == MERGE_HORIZ_PREV || mergeType == MERGE_BOTH_PREV) {
+                return true;
+            }
+            switch (mergeType) {
+                case MERGE_VERT_FIRST:
+                    os.write(RtfWriter.escape);
+                    os.write(cellVMergeFirst);
+                    break;
+                case MERGE_BOTH_FIRST:
+                    os.write(RtfWriter.escape);
+                    os.write(cellVMergeFirst);
+                    break;
+                case MERGE_HORIZ_PREV:
+                    os.write(RtfWriter.escape);
+                    os.write(cellMergePrev);
+                    break;
+                case MERGE_VERT_PREV:
+                    os.write(RtfWriter.escape);
+                    os.write(cellVMergePrev);
+                    break;
+                case MERGE_BOTH_PREV:
+                    os.write(RtfWriter.escape);
+                    os.write(cellMergeFirst);
+                    break;
+            }
+            switch (store.getVerticalAlignment()) {
+                case Element.ALIGN_BOTTOM:
+                    os.write(RtfWriter.escape);
+                    os.write(cellVerticalAlignBottom);
+                    break;
+                case Element.ALIGN_CENTER:
+                case Element.ALIGN_MIDDLE:
+                    os.write(RtfWriter.escape);
+                    os.write(cellVerticalAlignCenter);
+                    break;
+                case Element.ALIGN_TOP:
+                    os.write(RtfWriter.escape);
+                    os.write(cellVerticalAlignTop);
+                    break;
+            }
+
+            if (((store.getBorder() & Rectangle.LEFT) == Rectangle.LEFT) &&
+                    (lWidth > 0)) {
+                os.write(RtfWriter.escape);
+                os.write(cellBorderLeft);
+                os.write(RtfWriter.escape);
+                os.write(lStyle);
+                os.write(RtfWriter.escape);
+                os.write(RtfRow.tableBorderWidth);
+                writeInt(os, (int) (lWidth * RtfWriter.TWIPSFACTOR));
+                os.write(RtfWriter.escape);
+                os.write(RtfRow.tableBorderColor);
+                if (store.getBorderColor() == null)
+                    writeInt(os, writer.addColor(new
+                            Color(0, 0, 0)));
+                else
+                    writeInt(os, writer.addColor(store.getBorderColor()));
+                os.write((byte) '\n');
+            }
+            if (((store.getBorder() & Rectangle.TOP) == Rectangle.TOP) && (tWidth > 0)) {
+                os.write(RtfWriter.escape);
+                os.write(cellBorderTop);
+                os.write(RtfWriter.escape);
+                os.write(tStyle);
+                os.write(RtfWriter.escape);
+                os.write(RtfRow.tableBorderWidth);
+                writeInt(os, (int) (tWidth * RtfWriter.TWIPSFACTOR));
+                os.write(RtfWriter.escape);
+                os.write(RtfRow.tableBorderColor);
+                if (store.getBorderColor() == null)
+                    writeInt(os, writer.addColor(new
+                            Color(0, 0, 0)));
+                else
+                    writeInt(os, writer.addColor(store.getBorderColor()));
+                os.write((byte) '\n');
+            }
+            if (((store.getBorder() & Rectangle.BOTTOM) == Rectangle.BOTTOM) &&
+                    (bWidth > 0)) {
+                os.write(RtfWriter.escape);
+                os.write(cellBorderBottom);
+                os.write(RtfWriter.escape);
+                os.write(bStyle);
+                os.write(RtfWriter.escape);
+                os.write(RtfRow.tableBorderWidth);
+                writeInt(os, (int) (bWidth * RtfWriter.TWIPSFACTOR));
+                os.write(RtfWriter.escape);
+                os.write(RtfRow.tableBorderColor);
+                if (store.getBorderColor() == null)
+                    writeInt(os, writer.addColor(new
+                            Color(0, 0, 0)));
+                else
+                    writeInt(os, writer.addColor(store.getBorderColor()));
+                os.write((byte) '\n');
+            }
+            if (((store.getBorder() & Rectangle.RIGHT) == Rectangle.RIGHT) &&
+                    (rWidth > 0)) {
+                os.write(RtfWriter.escape);
+                os.write(cellBorderRight);
+                os.write(RtfWriter.escape);
+                os.write(rStyle);
+                os.write(RtfWriter.escape);
+                os.write(RtfRow.tableBorderWidth);
+                writeInt(os, (int) (rWidth * RtfWriter.TWIPSFACTOR));
+                os.write(RtfWriter.escape);
+                os.write(RtfRow.tableBorderColor);
+                if (store.getBorderColor() == null)
+                    writeInt(os, writer.addColor(new
+                            Color(0, 0, 0)));
+                else
+                    writeInt(os, writer.addColor(store.getBorderColor()));
+                os.write((byte) '\n');
+            }
+            os.write(RtfWriter.escape);
+            os.write(cellBackgroundColor);
+            if (store.getBackgroundColor() == null) {
+                writeInt(os, writer.addColor(new Color(255, 255, 255)));
+            } else {
+                writeInt(os, writer.addColor(store.getBackgroundColor()));
+            }
+            os.write((byte) '\n');
+            os.write(RtfWriter.escape);
+            os.write(cellWidthStyle);
+            os.write((byte) '\n');
+            os.write(RtfWriter.escape);
+            os.write(cellWidthTag);
+            writeInt(os, cellWidth);
+            os.write((byte) '\n');
+            if (cellpadding > 0) {
+                // values
+                os.write(RtfWriter.escape);
+                os.write(cellPaddingLeft);
+                writeInt(os, cellpadding / 2);
+                os.write(RtfWriter.escape);
+                os.write(cellPaddingTop);
+                writeInt(os, cellpadding / 2);
+                os.write(RtfWriter.escape);
+                os.write(cellPaddingRight);
+                writeInt(os, cellpadding / 2);
+                os.write(RtfWriter.escape);
+                os.write(cellPaddingBottom);
+                writeInt(os, cellpadding / 2);
+                // unit
+                os.write(RtfWriter.escape);
+                os.write(cellPaddingLeftUnit);
+                os.write(RtfWriter.escape);
+                os.write(cellPaddingTopUnit);
+                os.write(RtfWriter.escape);
+                os.write(cellPaddingRightUnit);
+                os.write(RtfWriter.escape);
+                os.write(cellPaddingBottomUnit);
+            }
+            os.write(RtfWriter.escape);
+            os.write(cellRightBorder);
+            writeInt(os, cellRight);
+        } catch (IOException e) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * Write the content of the <code>RtfCell</code>.
+     *
+     * @param os The <code>OutputStream</code> to which to write the content of
+     * the <code>RtfCell</code> to.
+     * @return true if writing the cell content succeeded
+     * @throws DocumentException
+     */
+    public boolean writeCellContent(ByteArrayOutputStream os) throws DocumentException {
+        try {
+            if (mergeType == MERGE_HORIZ_PREV || mergeType == MERGE_BOTH_PREV) {
+                return true;
+            }
+
+            if (!emptyCell) {
+                Iterator cellIterator = store.getElements();
+                Paragraph container = null;
+                while (cellIterator.hasNext()) {
+                    Element element = (Element) cellIterator.next();
+                    // should we wrap it in a paragraph
+                    if(!(element instanceof Paragraph)) {
+                        if(container != null) {
+                            container.add(element);
+                        } else {
+                            container = new Paragraph();
+                            container.setAlignment(store.getHorizontalAlignment());
+                            container.add(element);
+                        }
+                    } else {
+                        if(container != null) {
+                            writer.addElement(container, os);
+                            container =null;
+                            container =null;
+                        }
+
+
+                        // if horizontal alignment is undefined overwrite
+                        // with that of enclosing cell
+                        if (element instanceof Paragraph && ((Paragraph) element).getAlignment() == Element.ALIGN_UNDEFINED) {
+                            ((Paragraph) element).setAlignment(store.getHorizontalAlignment());
+                        }
+                        writer.addElement(element, os);
+                        if (element.type() == Element.PARAGRAPH && cellIterator.hasNext()) {
+                            os.write(RtfWriter.escape);
+                            os.write(RtfWriter.paragraph);
+                        }
+                    }
+                }
+                if(container != null) {
+                    writer.addElement(container, os);
+                    container =null;
+                }
+            } else {
+                os.write(RtfWriter.escape);
+                os.write(RtfWriter.paragraphDefaults);
+                os.write(RtfWriter.escape);
+                os.write(cellInTable);
+            }
+            os.write(RtfWriter.escape);
+            os.write(cellEnd);
+        } catch (IOException e) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * Sets the merge type and the <code>RtfCell</code> with which this
+     * <code>RtfCell</code> is to be merged.
+     *
+     * @param mergeType The merge type specifies the kind of merge to be applied
+     * (MERGE_HORIZ_PREV, MERGE_VERT_PREV, MERGE_BOTH_PREV)
+     * @param mergeCell The <code>RtfCell</code> that the cell at x and y is to
+     * be merged with
+     */
+    public void setMerge(int mergeType, RtfCell mergeCell) {
+        this.mergeType = mergeType;
+        store = mergeCell.getStore();
+    }
+
+    /**
+     * Get the <code>Cell</code> with the actual content.
+     *
+     * @return <code>Cell</code> which is contained in the <code>RtfCell</code>
+     */
+    public Cell getStore() {
+        return store;
+    }
+
+    /**
+     * Get the with of this <code>RtfCell</code>
+     *
+     * @return Width of the current <code>RtfCell</code>
+     */
+    public int getCellWidth() {
+        return cellWidth;
+    }
+
+    /**
+     * sets the width of the cell
+     * @param value a width
+     */
+    public void setCellWidth(int value) {
+        cellWidth = value;
+    }
+
+    /**
+     * Get the position of the right border of this <code>RtfCell</code>.
+     * @return position of the right border
+     */
+    public int getCellRight() {
+        return cellRight;
+    }
+
+
+    /**
+     * Sets the right position of the cell
+     * @param value a cell position
+     */
+    public void setCellRight(int value) {
+        cellRight = value;
+    }
+
+    /**
+     * Write an Integer to the Outputstream.
+     *
+     * @param out The <code>OutputStream</code> to be written to.
+     * @param i The int to be written.
+     * @throws IOException
+     */
+    private void writeInt(ByteArrayOutputStream out, int i) throws IOException {
+        out.write(Integer.toString(i).getBytes());
+    }
+}

Property changes on: src/core/com/lowagie/text/rtf/RtfCell.java
___________________________________________________________________
Added: svn:executable
   + *

Index: src/core/com/lowagie/text/rtf/RtfRow.java
===================================================================
--- src/core/com/lowagie/text/rtf/RtfRow.java	(revision 0)
+++ src/core/com/lowagie/text/rtf/RtfRow.java	(revision 0)
@@ -0,0 +1,443 @@
+/**
+ * $Id$
+ * $Name$
+ *
+ * Copyright 2001, 2002 by Mark Hall
+ *
+ * The contents of this file are subject to the Mozilla Public License Version 1.1
+ * (the "License"); you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the License.
+ *
+ * The Original Code is 'iText, a free JAVA-PDF library'.
+ *
+ * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
+ * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
+ * All Rights Reserved.
+ * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
+ * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
+ *
+ * Contributor(s): all the names of the contributors are added in the source code
+ * where applicable.
+ *
+ * Alternatively, the contents of this file may be used under the terms of the
+ * LGPL license (the ?GNU LIBRARY GENERAL PUBLIC LICENSE?), in which case the
+ * provisions of LGPL are applicable instead of those above.  If you wish to
+ * allow use of your version of this file only under the terms of the LGPL
+ * License and not to allow others to use your version of this file under
+ * the MPL, indicate your decision by deleting the provisions above and
+ * replace them with the notice and other provisions required by the LGPL.
+ * If you do not delete the provisions above, a recipient may use your version
+ * of this file under either the MPL or the GNU LIBRARY GENERAL PUBLIC LICENSE.
+ *
+ * This library is free software; you can redistribute it and/or modify it
+ * under the terms of the MPL as stated above or under the terms of the GNU
+ * Library General Public License as published by the Free Software Foundation;
+ * either version 2 of the License, or any later version.
+ *
+ * This library is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU Library general Public License for more
+ * details.
+ *
+ * If you didn't download this code from the following link, you should check if
+ * you aren't using an obsolete version:
+ * http://www.lowagie.com/iText/
+ */
+
+package com.lowagie.text.rtf;
+
+import com.lowagie.text.*;
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.io.*;
+import java.awt.Color;
+
+/**
+ * A Helper Class for the <CODE>RtfWriter</CODE>.
+ * <P>
+ * Do not use it directly
+ *
+ * ONLY FOR USE WITH THE RtfWriter NOT with the RtfWriter2.
+ *
+ * Parts of this Class were contributed by Steffen Stundzig. Many thanks for the
+ * improvements.
+ * Code added by c
+ * @deprecated Please move to the RtfWriter2 and associated classes.
+ */
+public class RtfRow {
+    /** Table border solid */
+    public static final byte[] tableBorder = "brdrs".getBytes();
+    /** Table border width */
+    public static final byte[] tableBorderWidth = "brdrw".getBytes();
+    /** Table border color */
+    public static final byte[] tableBorderColor = "brdrcf".getBytes();
+
+    /** Table row defaults */
+    private static final byte[] rowBegin = "trowd".getBytes();
+    /** End of table row */
+    private static final byte[] rowEnd = "row".getBytes();
+    /** Table row autofit */
+    private static final byte[] rowAutofit = "trautofit1".getBytes();
+    private static final byte[] graphLeft = "trgaph".getBytes();
+    /** Row border left */
+    private static final byte[] rowBorderLeft = "trbrdrl".getBytes();
+    /** Row border right */
+    private static final byte[] rowBorderRight = "trbrdrr".getBytes();
+    /** Row border top */
+    private static final byte[] rowBorderTop = "trbrdrt".getBytes();
+    /** Row border bottom */
+    private static final byte[] rowBorderBottom = "trbrdrb".getBytes();
+    /** Row border horiz inline */
+    private static final byte[] rowBorderInlineHorizontal = "trbrdrh".getBytes();
+    /** Row border bottom */
+    private static final byte[] rowBorderInlineVertical = "trbrdrv".getBytes();
+    /** Default cell spacing left */
+    private static final byte[] rowSpacingLeft = "trspdl".getBytes();
+    /** Default cell spacing right */
+    private static final byte[] rowSpacingRight = "trspdr".getBytes();
+    /** Default cell spacing top */
+    private static final byte[] rowSpacingTop = "trspdt".getBytes();
+    /** Default cell spacing bottom */
+    private static final byte[] rowSpacingBottom = "trspdb".getBytes();
+    /** Default cell spacing format left */
+    private static final byte[] rowSpacingLeftStyle = "trspdfl3".getBytes();
+    /** Default cell spacing format right */
+    private static final byte[] rowSpacingRightStyle = "trspdfr3".getBytes();
+    /** Default cell spacing format top */
+    private static final byte[] rowSpacingTopStyle = "trspdft3".getBytes();
+    /** Default cell spacing format bottom */
+    private static final byte[] rowSpacingBottomStyle = "trspdfb3".getBytes();
+    /** Default cell padding left */
+    private static final byte[] rowPaddingLeft = "trpaddl".getBytes();
+    /** Default cell padding right */
+    private static final byte[] rowPaddingRight = "trpaddr".getBytes();
+    /** Default cell padding format left */
+    private static final byte[] rowPaddingLeftStyle = "trpaddfl3".getBytes();
+    /** Default cell padding format right */
+    private static final byte[] rowPaddingRightStyle = "trpaddfr3".getBytes();
+    /** Row width format */
+    private static final byte[] rowWidthStyle = "trftsWidth3".getBytes();
+    /** Row width */
+    private static final byte[] rowWidth = "trwWidth".getBytes();
+    /**
+     * Table row header. This row should appear at the top of every
+     * page the current table appears on.
+     */
+    private static final byte[] rowHeader = "trhdr".getBytes();
+    /**
+     * Table row keep together. This row cannot be split by a page break.
+     * This property is assumed to be off unless the control word is
+     * present.
+     */
+    private static final byte[] rowKeep = "trkeep".getBytes();
+    /** Table alignment left */
+    private static final byte[] rowAlignLeft = "trql".getBytes();
+    /** Table alignment center */
+    private static final byte[] rowAlignCenter = "trqc".getBytes();
+    /** Table alignment right */
+    private static final byte[] rowAlignRight = "trqr".getBytes();
+
+    /** List of <code>RtfCell</code>s in this <code>RtfRow</code> */
+    private ArrayList cells = new ArrayList();
+    /** The <code>RtfWriter</code> to which this <code>RtfRow</code> belongs */
+    private RtfWriter writer = null;
+    /** The <coce>RtfTable</code> to which this <code>RtfRow</code> belongs */
+    private RtfTable mainTable = null;
+
+    /** The width of this <code>RtfRow</code> (in percent) */
+    private int width = 100;
+    /** The default cellpadding of <code>RtfCells</code> in this
+     * <code>RtfRow</code> */
+    private int cellpadding = 115;
+    /** The default cellspacing of <code>RtfCells</code> in this
+     * <code>RtfRow</code> */
+    private int cellspacing = 14;
+    /** The borders of this <code>RtfRow</code> */
+    private int borders = 0;
+    /** The border color of this <code>RtfRow</code> */
+    private java.awt.Color borderColor = null;
+    /** The border width of this <code>RtfRow</code> */
+    private float borderWidth = 0;
+
+    /** Original Row */
+    private Row origRow = null;
+
+    /**
+     * Create a new <code>RtfRow</code>.
+     *
+     * @param writer The <code>RtfWriter</code> that this <code>RtfRow</code> belongs to
+     * @param mainTable The <code>RtfTable</code> that created this
+     * <code>RtfRow</code>
+     */
+    public RtfRow(RtfWriter writer, RtfTable mainTable) {
+        super();
+        this.writer = writer;
+        this.mainTable = mainTable;
+    }
+
+    /**
+     * Pregenerate the <code>RtfCell</code>s in this <code>RtfRow</code>.
+     *
+     * @param columns The number of <code>RtfCell</code>s to be generated.
+     */
+    public void pregenerateRows(int columns) {
+        for (int i = 0; i < columns; i++) {
+            RtfCell rtfCell = new RtfCell(writer, mainTable);
+            cells.add(rtfCell);
+        }
+    }
+
+    /**
+     * Import a <code>Row</code>.
+     * <P>
+     * All the parameters are taken from the <code>RtfTable</code> which contains
+     * this <code>RtfRow</code> and they do exactely what they say
+     * @param row
+     * @param propWidths in percent
+     * @param tableWidth in percent
+     * @param pageWidth
+     * @param cellpadding
+     * @param cellspacing
+     * @param borders
+     * @param borderColor
+     * @param borderWidth
+     * @param y
+     * @return true if importing the row succeeded
+     */
+    public boolean importRow(Row row, float[] propWidths, int tableWidth, int pageWidth, int cellpadding,
+                             int cellspacing, int borders, java.awt.Color borderColor, float borderWidth,
+                             int y) {
+        // the width of this row is the absolute witdh, calculated from the
+        // proportional with of the table and the total width of the page
+        this.origRow = row;
+        this.width = pageWidth / 100 * tableWidth;
+        this.cellpadding = cellpadding;
+        this.cellspacing = cellspacing;
+        this.borders = borders;
+        this.borderColor = borderColor;
+        this.borderWidth = borderWidth;
+
+        if (this.borderWidth > 2) this.borderWidth = 2;
+
+        int cellLeft = 0;
+        for (int i = 0; i < row.getColumns(); i++) {
+            Element cell = (Element) row.getCell(i);
+
+            // cellWidth is an absolute argument
+            // it's based on the absolute of this row and the proportional
+            // width of this column
+            int cellWidth = (int) (width / 100 * propWidths[i]);
+            if (cell != null) {
+                if (cell.type() == Element.CELL) {
+                    RtfCell rtfCell = (RtfCell) cells.get(i);
+                    cellLeft = rtfCell.importCell((Cell) cell, cellLeft, cellWidth, i, y, cellpadding);
+                }
+            } else {
+                RtfCell rtfCell = (RtfCell) cells.get(i);
+                cellLeft = rtfCell.importCell(null, cellLeft, cellWidth, i, y, cellpadding);
+            }
+        }
+
+        // recalculate the cell right border and the cumulative width
+        // on col spanning cells.
+        // col + row spanning cells are also handled by this loop, because the real cell of
+        // the upper left corner in such an col, row matrix is copied as first cell
+        // in each row in this matrix
+        int columns = row.getColumns();
+        for (int i = 0; i < columns; i++) {
+            RtfCell firstCell = (RtfCell) cells.get(i);
+            Cell cell = firstCell.getStore();
+            int cols = 0;
+            if(cell != null) {
+                cols = cell.getColspan();
+            }
+            if (cols > 1) {
+                RtfCell lastCell = (RtfCell) cells.get(i + cols - 1);
+                firstCell.setCellRight(lastCell.getCellRight());
+                int width = firstCell.getCellWidth();
+                for (int j = i + 1; j < i + cols; j++) {
+                    RtfCell cCell = (RtfCell) cells.get(j);
+                    width += cCell.getCellWidth();
+                }
+                firstCell.setCellWidth(width);
+                i += cols - 1;
+            }
+        }
+        return true;
+    }
+
+    /**
+     * Write the <code>RtfRow</code> to the specified <code>OutputStream</code>.
+     *
+     * @param os The <code>OutputStream</code> to which this <code>RtfRow</code>
+     * should be written to.
+     * @param rowNum The <code>index</code> of this row in the containing table.
+     * @param table The <code>Table</code> which contains the original <code>Row</code>.
+     * @return true if writing the row succeeded
+     * @throws DocumentException
+     * @throws IOException
+     */
+    public boolean writeRow(ByteArrayOutputStream os, int rowNum, Table table) throws DocumentException,
+            IOException {
+        os.write(RtfWriter.escape);
+        os.write(rowBegin);
+        os.write((byte) '\n');
+        os.write(RtfWriter.escape);
+        os.write(rowWidthStyle);
+        os.write(RtfWriter.escape);
+        os.write(rowWidth);
+        writeInt(os, width);
+//        os.write(RtfWriter.escape);
+//        os.write(rowAutofit);
+        if (mainTable.getOriginalTable().isCellsFitPage()) {
+            os.write(RtfWriter.escape);
+            os.write(rowKeep);
+        }
+        // check if this row is a header row
+        if (rowNum < (table.getLastHeaderRow() + 1)) {
+            os.write(RtfWriter.escape);
+            os.write(rowHeader);
+        }
+        os.write(RtfWriter.escape);
+        switch (this.origRow.getHorizontalAlignment()) {
+            case Element.ALIGN_LEFT:
+                os.write(rowAlignLeft);
+                break;
+            case Element.ALIGN_CENTER:
+                os.write(rowAlignCenter);
+                break;
+            case Element.ALIGN_RIGHT:
+                os.write(rowAlignRight);
+                break;
+            default :
+                os.write(rowAlignLeft);
+                break;
+        }
+        os.write(RtfWriter.escape);
+        os.write(graphLeft);
+        writeInt(os, 10);
+        if (((borders & Rectangle.LEFT) == Rectangle.LEFT) && (borderWidth > 0)) {
+            writeBorder(os, rowBorderLeft);
+        }
+        if (((borders & Rectangle.TOP) == Rectangle.TOP) && (borderWidth > 0)) {
+            writeBorder(os, rowBorderTop);
+        }
+        if (((borders & Rectangle.BOTTOM) == Rectangle.BOTTOM) && (borderWidth > 0)) {
+            writeBorder(os, rowBorderBottom);
+        }
+        if (((borders & Rectangle.RIGHT) == Rectangle.RIGHT) && (borderWidth > 0)) {
+            writeBorder(os, rowBorderRight);
+        }
+        if (((borders & Rectangle.BOX) == Rectangle.BOX) && (borderWidth > 0)) {
+            writeBorder(os, rowBorderInlineHorizontal);
+            writeBorder(os, rowBorderInlineVertical);
+        }
+
+        if (cellspacing > 0) {
+            os.write(RtfWriter.escape);
+            os.write(rowSpacingLeft);
+            writeInt(os, cellspacing / 2);
+            os.write(RtfWriter.escape);
+            os.write(rowSpacingLeftStyle);
+            os.write(RtfWriter.escape);
+            os.write(rowSpacingTop);
+            writeInt(os, cellspacing / 2);
+            os.write(RtfWriter.escape);
+            os.write(rowSpacingTopStyle);
+            os.write(RtfWriter.escape);
+            os.write(rowSpacingBottom);
+            writeInt(os, cellspacing / 2);
+            os.write(RtfWriter.escape);
+            os.write(rowSpacingBottomStyle);
+            os.write(RtfWriter.escape);
+            os.write(rowSpacingRight);
+            writeInt(os, cellspacing / 2);
+            os.write(RtfWriter.escape);
+            os.write(rowSpacingRightStyle);
+        }
+        os.write(RtfWriter.escape);
+        os.write(rowPaddingLeft);
+        writeInt(os, cellpadding / 2);
+        os.write(RtfWriter.escape);
+        os.write(rowPaddingRight);
+        writeInt(os, cellpadding / 2);
+        os.write(RtfWriter.escape);
+        os.write(rowPaddingLeftStyle);
+        os.write(RtfWriter.escape);
+        os.write(rowPaddingRightStyle);
+        os.write((byte) '\n');
+
+        Iterator cellIterator = cells.iterator();
+        while (cellIterator.hasNext()) {
+            RtfCell cell = (RtfCell) cellIterator.next();
+            cell.writeCellSettings(os);
+        }
+
+        os.write(RtfWriter.escape);
+        os.write("intbl".getBytes());
+
+        cellIterator = cells.iterator();
+        while (cellIterator.hasNext()) {
+            RtfCell cell = (RtfCell) cellIterator.next();
+            cell.writeCellContent(os);
+        }
+        os.write(RtfWriter.delimiter);
+        os.write(RtfWriter.escape);
+        os.write(rowEnd);
+        return true;
+    }
+
+
+    private void writeBorder(ByteArrayOutputStream os, byte[] borderType) throws IOException {
+        // horizontal and vertical, top, left, bottom, right
+        os.write(RtfWriter.escape);
+        os.write(borderType);
+        // line style
+        os.write(RtfWriter.escape);
+        os.write(RtfRow.tableBorder);
+        // borderwidth
+        os.write(RtfWriter.escape);
+        os.write(RtfRow.tableBorderWidth);
+        writeInt(os, (int) (borderWidth * RtfWriter.TWIPSFACTOR));
+        // border color
+        os.write(RtfWriter.escape);
+        os.write(RtfRow.tableBorderColor);
+        if (borderColor == null) {
+            writeInt(os, writer.addColor(new Color(0, 0, 0)));
+        } else {
+            writeInt(os, writer.addColor(borderColor));
+        }
+        os.write((byte) '\n');
+    }
+
+
+    /**
+     * <code>RtfTable</code>s call this method from their own setMerge() to
+     * specify that a certain other cell is to be merged with it.
+     *
+     * @param x The column position of the cell to be merged
+     * @param mergeType The merge type specifies the kind of merge to be applied
+     * (MERGE_HORIZ_PREV, MERGE_VERT_PREV, MERGE_BOTH_PREV)
+     * @param mergeCell The <code>RtfCell</code> that the cell at x and y is to
+     * be merged with
+     */
+    public void setMerge(int x, int mergeType, RtfCell mergeCell) {
+        RtfCell cell = (RtfCell) cells.get(x);
+        cell.setMerge(mergeType, mergeCell);
+    }
+
+    /*
+     * Write an Integer to the Outputstream.
+     *
+     * @param out The <code>OutputStream</code> to be written to.
+     * @param i The int to be written.
+     */
+    private void writeInt(ByteArrayOutputStream out, int i) throws IOException {
+        out.write(Integer.toString(i).getBytes());
+    }
+}

Property changes on: src/core/com/lowagie/text/rtf/RtfRow.java
___________________________________________________________________
Added: svn:executable
   + *

Index: src/core/com/lowagie/text/xml/XmlToPdf.java
===================================================================
--- src/core/com/lowagie/text/xml/XmlToPdf.java	(revision 0)
+++ src/core/com/lowagie/text/xml/XmlToPdf.java	(revision 0)
@@ -0,0 +1,144 @@
+/*
+ * Copyright 2002 by Matt Benson.
+ *
+ * The contents of this file are subject to the Mozilla Public License Version 1.1
+ * (the "License"); you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the License.
+ *
+ * The Original Code is 'iText, a free JAVA-PDF library'.
+ *
+ * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
+ * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
+ * All Rights Reserved.
+ * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
+ * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
+ *
+ * Contributor(s): all the names of the contributors are added in the source code
+ * where applicable.
+ *
+ * Alternatively, the contents of this file may be used under the terms of the
+ * LGPL license (the "GNU LIBRARY GENERAL PUBLIC LICENSE"), in which case the
+ * provisions of LGPL are applicable instead of those above.  If you wish to
+ * allow use of your version of this file only under the terms of the LGPL
+ * License and not to allow others to use your version of this file under
+ * the MPL, indicate your decision by deleting the provisions above and
+ * replace them with the notice and other provisions required by the LGPL.
+ * If you do not delete the provisions above, a recipient may use your version
+ * of this file under either the MPL or the GNU LIBRARY GENERAL PUBLIC LICENSE.
+ *
+ * This library is free software; you can redistribute it and/or modify it
+ * under the terms of the MPL as stated above or under the terms of the GNU
+ * Library General Public License as published by the Free Software Foundation;
+ * either version 2 of the License, or any later version.
+ *
+ * This library is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU Library general Public License for more
+ * details.
+ *
+ * If you didn't download this code from the following link, you should check if
+ * you aren't using an obsolete version:
+ * http://www.lowagie.com/iText/
+ */
+
+package com.lowagie.text.xml;
+
+
+import java.io.OutputStream;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+
+import com.lowagie.text.Document;
+import com.lowagie.text.DocumentException;
+import com.lowagie.text.pdf.PdfWriter;
+
+
+/**
+ * PDF-specific subclass of <code>XmlToXXX</code>.
+ *
+ * @version 1.0
+ * @author <a href="mailto:orangeherbert@users.sourceforge.net">Matt Benson</a>
+ */
+public class XmlToPdf
+ extends XmlToXXX
+{
+	
+/**
+ * Construct an <CODE>XmlToPdf</CODE> with the default page size.
+ */
+	public XmlToPdf()
+	{
+		super();
+	}//end default constructor
+	
+	
+/**
+ * Construct an <CODE>XmlToPdf</CODE> with the specified page size.
+ * @param pageSize   <CODE>String</CODE> page size name from
+ * <CODE>com.lowagie.text.PageSize</CODE>.
+ */
+	public XmlToPdf(String pageSize)
+	{
+		super(pageSize);
+	}//end constructor(String)
+	
+	
+/**
+ * Add a <CODE>DocWriter</CODE> for the specified <CODE>Document</CODE> and
+ * <CODE>OutputStream</CODE>.
+ * @param doc The document to which content will be added
+ * @param out The outputstream to which the PDF will be sent
+ * @throws DocumentException if document errors occur.
+ */	
+	protected final void addWriter(Document doc, OutputStream out)
+	 throws DocumentException
+	{
+		PdfWriter.getInstance(doc, out);
+	}//end addWriter
+	
+	
+/**
+ * Main method of the <CODE>XmlToPdf</CODE> class.
+ * @param args   <CODE>String[]</CODE> of command-line arguments.
+ */
+	public static void main(String[] args)
+	{
+		int code = 0;
+		
+		if (args.length > 1)
+		{
+			try
+			{
+				XmlToPdf x;
+				if (args.length > 2)
+				{
+					x = new XmlToPdf(args[2]);
+				}//end if at least 3 args
+				else
+				{
+					x = new XmlToPdf();
+				}//end else, only 2 args
+				
+				x.parse(new FileInputStream(args[0]), new FileOutputStream(args[1]));
+			}//end try to do everything
+			catch (Exception ex)
+			{
+				code = 2;
+				ex.printStackTrace(System.err);
+			}//end catch Exception
+		}//end if at least 2 args
+		else
+		{
+			code = 1;
+			System.err.println(
+			 "Usage:  XmlToPdf [XML file in] [PDF file out] [optional page size]");
+		}//end else, not enough arguments
+		
+		System.exit(code);
+	}//end main
+	
+}//end class XmlToPdf
Index: src/core/com/lowagie/text/rtf/RtfHeaderFooters.java
===================================================================
--- src/core/com/lowagie/text/rtf/RtfHeaderFooters.java	(revision 0)
+++ src/core/com/lowagie/text/rtf/RtfHeaderFooters.java	(revision 0)
@@ -0,0 +1,160 @@
+/**
+ * $Id$
+ *
+ * Copyright 2002 by 
+ * <a href="http://www.smb-tec.com">SMB</a> 
+ * <a href="mailto:Steffen.Stundzig@smb-tec.com">Steffen.Stundzig@smb-tec.com</a>
+ *
+ * The contents of this file are subject to the Mozilla Public License Version 1.1
+ * (the "License"); you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the License.
+ *
+ * The Original Code is 'iText, a free JAVA-PDF library'.
+ *
+ * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
+ * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
+ * All Rights Reserved.
+ * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
+ * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
+ *
+ * Contributor(s): all the names of the contributors are added in the source code
+ * where applicable.
+ *
+ * Alternatively, the contents of this file may be used under the terms of the
+ * LGPL license (the ?GNU LIBRARY GENERAL PUBLIC LICENSE?), in which case the
+ * provisions of LGPL are applicable instead of those above.  If you wish to
+ * allow use of your version of this file only under the terms of the LGPL
+ * License and not to allow others to use your version of this file under
+ * the MPL, indicate your decision by deleting the provisions above and
+ * replace them with the notice and other provisions required by the LGPL.
+ * If you do not delete the provisions above, a recipient may use your version
+ * of this file under either the MPL or the GNU LIBRARY GENERAL PUBLIC LICENSE.
+ *
+ * This library is free software; you can redistribute it and/or modify it
+ * under the terms of the MPL as stated above or under the terms of the GNU
+ * Library General Public License as published by the Free Software Foundation;
+ * either version 2 of the License, or any later version.
+ *
+ * This library is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without right the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU Library general Public License for more
+ * details.
+ *
+ * If you didn't download this code from the following link, you should check if
+ * you aren't using an obsolete version:
+ * http://www.lowagie.com/iText/
+ */
+
+package com.lowagie.text.rtf;
+
+import com.lowagie.text.HeaderFooter;
+import com.lowagie.text.Phrase;
+
+
+/**
+ * This HeaderFooter specialization contains some headers or footers for several
+ * pages. Is a list of headerFooters but also a sub class of header footer, to change
+ * as less as possible of the current API.
+ * 
+ * ONLY FOR USE WITH THE RtfWriter NOT with the RtfWriter2.
+ *
+ * This class is based on the RtfWriter-package from Mark Hall.
+ * @author <a href="mailto:Steffen.Stundzig@smb-tec.com">Steffen.Stundzig@smb-tec.com</a> 
+ * @author <a href="mailto:mhall@myrealbox.com">Mark.Hall@myrealbox.com</a>
+ * @version $Revision$Date: 2009/08/28 20:31:00 $
+ * @deprecated Please move to the RtfWriter2 and associated classes. com.lowagie.text.rtf.headerfooter.RtfHeaderFooterGroup replaces the functionality of this class.
+ */
+public class RtfHeaderFooters extends HeaderFooter {
+	/** an attribute value */
+    public final static int ALL_PAGES = 0;
+	/** an attribute value */
+    public final static int LEFT_PAGES = 1;
+	/** an attribute value */
+    public final static int RIGHT_PAGES = 2;
+	/** an attribute value */
+    public final static int FIRST_PAGE = 3;
+    
+//    public int defaultHeader = ALL_PAGES;
+
+	/** header or footer placeholder */
+    private HeaderFooter allPages = null;
+	/** header or footer placeholder */
+    private HeaderFooter leftPages = null;
+	/** header or footer placeholder */
+    private HeaderFooter rightPages = null;
+	/** header or footer placeholder */
+    private HeaderFooter firstPage = null;
+
+    /**
+     * Contructs a HeaderFooters object
+     */
+    public RtfHeaderFooters() {
+        super( new Phrase(""), false );
+    }
+
+    /**
+     * Contructs a HeaderFooters object
+     * @param before
+     * @param after
+     */
+    public RtfHeaderFooters( Phrase before, Phrase after ) {
+        super( before, after );
+    }
+
+    /**
+     * Contructs a HeaderFooters object
+     * @param before
+     * @param numbered
+     */
+    public RtfHeaderFooters( Phrase before, boolean numbered ) {
+        super( before, numbered );
+    }
+
+    /**
+     * Adds a HeaderFooter to this HeaderFooters object
+     * @param type
+     * @param hf
+     */
+    public void set( int type, HeaderFooter hf ) {
+        switch (type) {
+            case ALL_PAGES:
+                allPages = hf;
+                break;
+            case LEFT_PAGES:
+                leftPages = hf;
+                break;
+            case RIGHT_PAGES:
+                rightPages = hf;
+                break;
+            case FIRST_PAGE:
+                firstPage = hf;
+                break;
+            default:
+                throw new IllegalStateException( "unknown type " + type );
+        }
+    }
+
+    /**
+     * Returns a type of HeaderFooter object registered in this HeaderFooters object.
+     * @param type type of the HeaderFooter object
+     * @return a HeaderFooter object
+     */
+    public HeaderFooter get( int type ) {
+        switch (type) {
+            case ALL_PAGES:
+                return allPages;
+            case LEFT_PAGES:
+                return leftPages;
+            case RIGHT_PAGES:
+                return rightPages;
+            case FIRST_PAGE:
+                return firstPage;
+            default:
+                throw new IllegalStateException( "unknown type " + type );
+        }
+    }    
+}

Property changes on: src/core/com/lowagie/text/rtf/RtfHeaderFooters.java
___________________________________________________________________
Added: svn:executable
   + *

Index: src/core/com/lowagie/text/xml/XmlToRtf.java
===================================================================
--- src/core/com/lowagie/text/xml/XmlToRtf.java	(revision 0)
+++ src/core/com/lowagie/text/xml/XmlToRtf.java	(revision 0)
@@ -0,0 +1,144 @@
+/*
+ * Copyright 2002 by Matt Benson.
+ *
+ * The contents of this file are subject to the Mozilla Public License Version 1.1
+ * (the "License"); you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the License.
+ *
+ * The Original Code is 'iText, a free JAVA-PDF library'.
+ *
+ * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
+ * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
+ * All Rights Reserved.
+ * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
+ * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
+ *
+ * Contributor(s): all the names of the contributors are added in the source code
+ * where applicable.
+ *
+ * Alternatively, the contents of this file may be used under the terms of the
+ * LGPL license (the "GNU LIBRARY GENERAL PUBLIC LICENSE"), in which case the
+ * provisions of LGPL are applicable instead of those above.  If you wish to
+ * allow use of your version of this file only under the terms of the LGPL
+ * License and not to allow others to use your version of this file under
+ * the MPL, indicate your decision by deleting the provisions above and
+ * replace them with the notice and other provisions required by the LGPL.
+ * If you do not delete the provisions above, a recipient may use your version
+ * of this file under either the MPL or the GNU LIBRARY GENERAL PUBLIC LICENSE.
+ *
+ * This library is free software; you can redistribute it and/or modify it
+ * under the terms of the MPL as stated above or under the terms of the GNU
+ * Library General Public License as published by the Free Software Foundation;
+ * either version 2 of the License, or any later version.
+ *
+ * This library is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU Library general Public License for more
+ * details.
+ *
+ * If you didn't download this code from the following link, you should check if
+ * you aren't using an obsolete version:
+ * http://www.lowagie.com/iText/
+ */
+
+package com.lowagie.text.xml;
+
+
+import java.io.OutputStream;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+
+import com.lowagie.text.Document;
+import com.lowagie.text.DocumentException;
+import com.lowagie.text.rtf.RtfWriter;
+
+
+/**
+ * RTF-specific subclass of <code>XmlToXXX</code>.
+ *
+ * @version 1.0
+ * @author <a href="mailto:orangeherbert@users.sourceforge.net">Matt Benson</a>
+ */
+public class XmlToRtf
+ extends XmlToXXX
+{
+	
+/**
+ * Construct an <CODE>XmlToRtf</CODE> with the default page size.
+ */
+	public XmlToRtf()
+	{
+		super();
+	}//end default constructor
+	
+	
+/**
+ * Construct an <CODE>XmlToRtf</CODE> with the specified page size.
+ * @param pageSize   <CODE>String</CODE> page size name from
+ * <CODE>com.lowagie.text.PageSize</CODE>.
+ */
+	public XmlToRtf(String pageSize)
+	{
+		super(pageSize);
+	}//end constructor(String)
+	
+	
+/**
+ * Add a <CODE>DocWriter</CODE> for the specified <CODE>Document</CODE> and
+ * <CODE>OutputStream</CODE>.
+ * @param doc The document to which content will be added
+ * @param out The outputstream to which RTF will be sent
+ * @throws DocumentException if document errors occur.
+ */	
+	protected final void addWriter(Document doc, OutputStream out)
+	 throws DocumentException
+	{
+		RtfWriter.getInstance(doc, out);
+	}//end addWriter
+	
+	
+/**
+ * Main method of the <CODE>XmlToRtf</CODE> class.
+ * @param args   <CODE>String[]</CODE> of command-line arguments.
+ */
+	public static void main(String[] args)
+	{
+		int code = 0;
+		
+		if (args.length > 1)
+		{
+			try
+			{
+				XmlToRtf x;
+				if (args.length > 2)
+				{
+					x = new XmlToRtf(args[2]);
+				}//end if at least 3 args
+				else
+				{
+					x = new XmlToRtf();
+				}//end else, only 2 args
+				
+				x.parse(new FileInputStream(args[0]), new FileOutputStream(args[1]));
+			}//end try to do everything
+			catch (Exception ex)
+			{
+				code = 2;
+				ex.printStackTrace(System.err);
+			}//end catch Exception
+		}//end if at least 2 args
+		else
+		{
+			code = 1;
+			System.err.println(
+			 "Usage:  XmlToRtf [XML file in] [PDF file out] [optional page size]");
+		}//end else, not enough arguments
+		
+		System.exit(code);
+	}//end main
+	
+}//end class XmlToRtf
Index: src/core/com/lowagie/text/rtf/GenericRtfField.java
===================================================================
--- src/core/com/lowagie/text/rtf/GenericRtfField.java	(revision 0)
+++ src/core/com/lowagie/text/rtf/GenericRtfField.java	(revision 0)
@@ -0,0 +1,139 @@
+/**
+ * $Id$
+ *
+ * Copyright 2002 by 
+ * <a href="http://www.smb-tec.com">SMB</a> 
+ * <a href="mailto:Dirk.Weigenand@smb-tec.com">Dirk.Weigenand@smb-tec.com</a>
+ *
+ * The contents of this file are subject to the Mozilla Public License Version 1.1
+ * (the "License"); you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the License.
+ *
+ * The Original Code is 'iText, a free JAVA-PDF library'.
+ *
+ * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
+ * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
+ * All Rights Reserved.
+ * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
+ * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
+ *
+ * Contributor(s): all the names of the contributors are added in the source code
+ * where applicable.
+ *
+ * Alternatively, the contents of this file may be used under the terms of the
+ * LGPL license (the GNU LIBRARY GENERAL PUBLIC LICENSE), in which case the
+ * provisions of LGPL are applicable instead of those above.  If you wish to
+ * allow use of your version of this file only under the terms of the LGPL
+ * License and not to allow others to use your version of this file under
+ * the MPL, indicate your decision by deleting the provisions above and
+ * replace them with the notice and other provisions required by the LGPL.
+ * If you do not delete the provisions above, a recipient may use your version
+ * of this file under either the MPL or the GNU LIBRARY GENERAL PUBLIC LICENSE.
+
+ *
+ * This library is free software; you can redistribute it and/or modify it
+ * under the terms of the MPL as stated above or under the terms of the GNU
+ * Library General Public License as published by the Free Software Foundation;
+ * either version 2 of the License, or any later version.
+ *
+ * This library is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU Library general Public License for more
+ * details.
+ *
+ * If you didn't download this code from the following link, you should check if
+ * you aren't using an obsolete version:
+ * http://www.lowagie.com/iText/
+ */
+
+package com.lowagie.text.rtf;
+
+import java.io.IOException;
+import java.io.OutputStream;
+
+import com.lowagie.text.Font;
+
+
+/**
+ * This class implements a generic RtfField.
+ *
+ * This class is based on the RtfWriter-package from Mark Hall.
+ * 
+ * ONLY FOR USE WITH THE RtfWriter NOT with the RtfWriter2.
+ *
+ * @author <a href="mailto:Dirk.Weigenand@smb-tec.com">Dirk Weigenand</a>
+ * @version $Id$
+ * @since Mon Aug 19 14:50:39 2002
+ * @deprecated Please move to the RtfWriter2 and associated classes.
+ */
+public class GenericRtfField extends AbstractRtfField implements RtfField {
+    /**
+     * Field Initialization Stuff.
+     */
+    protected String fieldInst;
+
+    /**
+     * Field Result Stuff.
+     */
+    protected String fieldResult;
+
+    /**
+     * public constructor, set the data that is to be written into the
+     * Field Initialization Stuff and Field Result parts of the
+     * RtfField.
+     *
+     * @param fieldInst data to be written into the Field
+     * Initialization Stuff part of the RtfField.
+     * @param fieldResult data to be written into the Field Result
+     * part of the RtfField.
+     */
+    public GenericRtfField(final String fieldInst, final String fieldResult) {
+        super("x", new Font());
+        this.fieldInst = fieldInst;
+        this.fieldResult = fieldResult;
+    }
+
+    /**
+     * public constructor, set the data that is to be written into the
+     * Field Initialization Stuff and Field Result parts of the
+     * RtfField.
+     *
+     * @param fieldInst data to be written into the Field
+     * Initialization Stuff part of the RtfField.
+     * @param fieldResult data to be written into the Field Result
+     * part of the RtfField.
+     * @param font
+     */
+    public GenericRtfField(final String fieldInst, final String fieldResult, Font font) {
+        super("x", font);
+        this.fieldInst = fieldInst;
+        this.fieldResult = fieldResult;
+    }
+
+    /**
+     * method for writing custom stuff to the Field Initialization
+     * Stuff part of an RtfField.
+     * @param out
+     * @throws IOException
+     */
+    public void writeRtfFieldInitializationStuff(OutputStream out) throws IOException {
+        out.write(fieldInst.trim().getBytes());
+        out.write(RtfWriter.delimiter);
+    }
+
+    /**
+     * method for writing custom stuff to the Field Result part of an
+     * RtfField.
+     * @param out
+     * @throws IOException
+     */
+    public void writeRtfFieldResultStuff(OutputStream out) throws IOException {
+        if (null != fieldResult) {
+            out.write(fieldResult.trim().getBytes());
+        }
+    }
+}
Index: src/core/com/lowagie/text/rtf/RtfTOCEntry.java
===================================================================
--- src/core/com/lowagie/text/rtf/RtfTOCEntry.java	(revision 0)
+++ src/core/com/lowagie/text/rtf/RtfTOCEntry.java	(revision 0)
@@ -0,0 +1,174 @@
+/**
+ * $Id$
+ *
+ * Copyright 2002 by
+ * <a href="http://www.smb-tec.com">SMB</a>
+ * <a href="mailto:Steffen.Stundzig@smb-tec.com">Steffen.Stundzig@smb-tec.com</a>
+ *
+ * The contents of this file are subject to the Mozilla Public License Version 1.1
+ * (the "License"); you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the License.
+ *
+ * The Original Code is 'iText, a free JAVA-PDF library'.
+ *
+ * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
+ * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
+ * All Rights Reserved.
+ * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
+ * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
+ *
+ * Contributor(s): all the names of the contributors are added in the source code
+ * where applicable.
+ *
+ * Alternatively, the contents of this file may be used under the terms of the
+ * LGPL license (the �GNU LIBRARY GENERAL PUBLIC LICENSE�), in which case the
+ * provisions of LGPL are applicable instead of those above.  If you wish to
+ * allow use of your version of this file only under the terms of the LGPL
+ * License and not to allow others to use your version of this file under
+ * the MPL, indicate your decision by deleting the provisions above and
+ * replace them with the notice and other provisions required by the LGPL.
+ * If you do not delete the provisions above, a recipient may use your version
+ * of this file under either the MPL or the GNU LIBRARY GENERAL PUBLIC LICENSE.
+ *
+ * This library is free software; you can redistribute it and/or modify it
+ * under the terms of the MPL as stated above or under the terms of the GNU
+ * Library General Public License as published by the Free Software Foundation;
+ * either version 2 of the License, or any later version.
+ *
+ * This library is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU Library general Public License for more
+ * details.
+ *
+ * If you didn't download this code from the following link, you should check if
+ * you aren't using an obsolete version:
+ * http://www.lowagie.com/iText/
+ */
+
+package com.lowagie.text.rtf;
+
+import java.io.IOException;
+import java.io.OutputStream;
+
+import com.lowagie.text.Chunk;
+import com.lowagie.text.Font;
+
+/**
+ * This class can be used to insert entries for a table of contents into
+ * the RTF document.
+ *
+ * ONLY FOR USE WITH THE RtfWriter NOT with the RtfWriter2.
+ *
+ * This class is based on the RtfWriter-package from Mark Hall.
+ * @author <a href="mailto:Steffen.Stundzig@smb-tec.com">Steffen.Stundzig@smb-tec.com</a>
+ * @version $Revision$Date: 2009/08/28 20:31:00 $
+ * @deprecated Please move to the RtfWriter2 and associated classes. com.lowagie.text.rtf.field.RtfTOCEntry replaces the functionality of this class.
+ */
+public class RtfTOCEntry extends Chunk implements RtfField {
+
+
+    private boolean         hideText = false;
+
+    private boolean         hidePageNumber = false;
+
+    private String    entryName;
+
+    private Font      entryFont;
+
+    private Font      contentFont;
+
+
+    /**
+     * Constructs an entry for the Table of Contents
+     * @param content the content of the entry
+     * @param contentFont the font
+     */
+    public RtfTOCEntry( String content, Font contentFont ) {
+        this( content, contentFont, content, contentFont );
+//        super( content, font );
+//        this.entryName = content;
+//        printEntryNameAsText = true;
+    }
+
+
+    /**
+     * Constructs an entry for the Table of Contents
+     * @param content the content of the entry
+     * @param contentFont the font
+     * @param entryName name of the entry
+     * @param entryFont font of the entryname
+     */
+    public RtfTOCEntry( String content, Font contentFont, String entryName, Font entryFont ) {
+        super( content, contentFont );
+        // hide the text of the entry, because it is printed
+        this.entryName = entryName;
+        this.entryFont = entryFont;
+        this.contentFont = contentFont;
+    }
+
+    /**
+     * @see com.lowagie.text.rtf.RtfField#write(com.lowagie.text.rtf.RtfWriter, java.io.OutputStream)
+     */
+    public void write( RtfWriter writer, OutputStream out ) throws IOException {
+
+        if (!hideText) {
+            writer.writeInitialFontSignature( out, new Chunk("", contentFont) );
+            out.write( RtfWriter.filterSpecialChar( getContent(), true ).getBytes() );
+            writer.writeFinishingFontSignature( out, new Chunk("", contentFont) );
+        }
+
+        if (!entryFont.equals( contentFont )) {
+            writer.writeInitialFontSignature(out, new Chunk("", entryFont) );
+            writeField( out );
+            writer.writeFinishingFontSignature(out, new Chunk("", entryFont) );
+        } else {
+            writer.writeInitialFontSignature(out, new Chunk("", contentFont) );
+            writeField( out );
+            writer.writeFinishingFontSignature(out, new Chunk("", contentFont) );
+        }
+    }
+
+
+    private void writeField( OutputStream out ) throws IOException {
+
+        // always hide the toc entry
+        out.write( RtfWriter.openGroup );
+        out.write( RtfWriter.escape );
+        out.write( "v".getBytes() );
+
+        // tc field entry
+        out.write( RtfWriter.openGroup );
+        out.write( RtfWriter.escape );
+        if (!hidePageNumber) {
+            out.write( "tc".getBytes() );
+        } else {
+            out.write( "tcn".getBytes() );
+        }
+        out.write( RtfWriter.delimiter );
+        out.write( RtfWriter.filterSpecialChar( entryName, true ).getBytes() );
+        out.write( RtfWriter.delimiter );
+        out.write( RtfWriter.closeGroup );
+
+        out.write( RtfWriter.closeGroup );
+    }
+
+    /**
+     * sets the hideText value to true
+     */
+    public void hideText() {
+        hideText = true;
+    }
+
+    /**
+     * sets the hidePageNumber value to true
+     */
+    public void hidePageNumber() {
+        hidePageNumber = true;
+    }
+}
+
+

Property changes on: src/core/com/lowagie/text/rtf/RtfTOCEntry.java
___________________________________________________________________
Added: svn:executable
   + *

Index: src/core/com/lowagie/text/rtf/RtfPageNumber.java
===================================================================
--- src/core/com/lowagie/text/rtf/RtfPageNumber.java	(revision 0)
+++ src/core/com/lowagie/text/rtf/RtfPageNumber.java	(revision 0)
@@ -0,0 +1,105 @@
+/**
+ * $Id$
+ *
+ * Copyright 2002 by 
+ * <a href="http://www.smb-tec.com">SMB</a> 
+ * <a href="mailto:Steffen.Stundzig@smb-tec.com">Steffen.Stundzig@smb-tec.com</a>
+ *
+ * The contents of this file are subject to the Mozilla Public License Version 1.1
+ * (the "License"); you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the License.
+ *
+ * The Original Code is 'iText, a free JAVA-PDF library'.
+ *
+ * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
+ * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
+ * All Rights Reserved.
+ * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
+ * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
+ *
+ * Contributor(s): all the names of the contributors are added in the source code
+ * where applicable.
+ *
+ * Alternatively, the contents of this file may be used under the terms of the
+ * LGPL license (the ?GNU LIBRARY GENERAL PUBLIC LICENSE?), in which case the
+ * provisions of LGPL are applicable instead of those above.  If you wish to
+ * allow use of your version of this file only under the terms of the LGPL
+ * License and not to allow others to use your version of this file under
+ * the MPL, indicate your decision by deleting the provisions above and
+ * replace them with the notice and other provisions required by the LGPL.
+ * If you do not delete the provisions above, a recipient may use your version
+ * of this file under either the MPL or the GNU LIBRARY GENERAL PUBLIC LICENSE.
+ *
+ * This library is free software; you can redistribute it and/or modify it
+ * under the terms of the MPL as stated above or under the terms of the GNU
+ * Library General Public License as published by the Free Software Foundation;
+ * either version 2 of the License, or any later version.
+ *
+ * This library is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU Library general Public License for more
+ * details.
+ *
+ * If you didn't download this code from the following link, you should check if
+ * you aren't using an obsolete version:
+ * http://www.lowagie.com/iText/
+ */
+
+package com.lowagie.text.rtf;
+
+import java.io.IOException;
+import java.io.OutputStream;
+
+import com.lowagie.text.Font;
+
+/**
+ * A rtf page number field.
+ * 
+ * ONLY FOR USE WITH THE RtfWriter NOT with the RtfWriter2.
+ *
+ * This class is based on the RtfWriter-package from Mark Hall.
+ * @author <a href="mailto:Steffen.Stundzig@smb-tec.com">Steffen.Stundzig@smb-tec.com</a>
+ * @author <a href="mailto:mhall@myrealbox.com">mhall@myrealbox.com</a>
+ * @version $Revision$Date: 2009/08/28 20:31:00 $
+ * @deprecated Please move to the RtfWriter2 and associated classes. com.lowagie.text.rtf.field.RtfPageNumber replaces the functionality of this class.
+ */
+public class RtfPageNumber extends GenericRtfField implements RtfField {
+    private String content;
+
+    /**
+     * construct a RtfPageNumber. The parameter content will be
+     * displayed in front of the page number using the font given as
+     * second argument.
+     * @param content the String that will be displayed in front of the page number
+     * @param contentFont the font to use to display this page number
+     */
+    public RtfPageNumber( String content, Font contentFont ) {
+        super("PAGE", "", contentFont);
+        this.content = content;
+    }
+
+    /**
+     * write this RtfField into a stream using the writer given as
+     * first argument.
+     * @param writer the RtfWriter to use to write this RtfField
+     * @param out the Stream to write this RtfField into.
+     * @throws IOException
+     */
+    public void write( RtfWriter writer, OutputStream out ) throws IOException {
+        writer.writeInitialFontSignature( out, this );
+        out.write(content.getBytes());
+        writer.writeFinishingFontSignature( out, this );
+        super.write(writer, out);
+    }
+
+    /**
+     * @see com.lowagie.text.Element#toString()
+     */
+    public String toString() {
+        return content;
+    }
+}

Property changes on: src/core/com/lowagie/text/rtf/RtfPageNumber.java
___________________________________________________________________
Added: svn:executable
   + *

Index: src/core/com/lowagie/text/rtf/RtfField.java
===================================================================
--- src/core/com/lowagie/text/rtf/RtfField.java	(revision 0)
+++ src/core/com/lowagie/text/rtf/RtfField.java	(revision 0)
@@ -0,0 +1,84 @@
+/**
+ * $Id$
+ *
+ * Copyright 2002 by 
+ * <a href="http://www.smb-tec.com">SMB</a> 
+ * <a href="mailto:Steffen.Stundzig@smb-tec.com">Steffen.Stundzig@smb-tec.com</a>
+ *
+ * The contents of this file are subject to the Mozilla Public License Version 1.1
+ * (the "License"); you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the License.
+ *
+ * The Original Code is 'iText, a free JAVA-PDF library'.
+ *
+ * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
+ * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
+ * All Rights Reserved.
+ * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
+ * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
+ *
+ * Contributor(s): all the names of the contributors are added in the source code
+ * where applicable.
+ *
+ * Alternatively, the contents of this file may be used under the terms of the
+ * LGPL license (the GNU LIBRARY GENERAL PUBLIC LICENSE), in which case the
+ * provisions of LGPL are applicable instead of those above.  If you wish to
+ * allow use of your version of this file only under the terms of the LGPL
+ * License and not to allow others to use your version of this file under
+ * the MPL, indicate your decision by deleting the provisions above and
+ * replace them with the notice and other provisions required by the LGPL.
+ * If you do not delete the provisions above, a recipient may use your version
+ * of this file under either the MPL or the GNU LIBRARY GENERAL PUBLIC LICENSE.
+
+ *
+ * This library is free software; you can redistribute it and/or modify it
+ * under the terms of the MPL as stated above or under the terms of the GNU
+ * Library General Public License as published by the Free Software Foundation;
+ * either version 2 of the License, or any later version.
+ *
+ * This library is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU Library general Public License for more
+ * details.
+ *
+ * If you didn't download this code from the following link, you should check if
+ * you aren't using an obsolete version:
+ * http://www.lowagie.com/iText/
+ */
+
+package com.lowagie.text.rtf;
+
+import com.lowagie.text.rtf.RtfWriter;
+
+import java.io.OutputStream;
+import java.io.IOException;
+
+
+/**
+ * This interface should mark classes, that can be represented 
+ * as RTF fields, such as pagenumber, toc entries and so on.
+ * 
+ * ONLY FOR USE WITH THE RtfWriter NOT with the RtfWriter2.
+ *
+ * This class is based on the RtfWriter-package from Mark Hall.
+ * @author <a href="mailto:Steffen.Stundzig@smb-tec.com">Steffen.Stundzig@smb-tec.com</a> 
+ * @version $Revision$Date: 2009/08/28 20:31:00 $
+ * @deprecated Please move to the RtfWriter2 and associated classes.
+ */
+public interface RtfField {
+
+
+    /**
+     * Writes an RTF field.
+     * @param writer
+     * @param out
+     * @throws IOException
+     */
+    public void write( RtfWriter writer, OutputStream out ) throws IOException;
+}
+
+

Property changes on: src/core/com/lowagie/text/rtf/RtfField.java
___________________________________________________________________
Added: svn:executable
   + *

Index: src/core/com/lowagie/text/rtf/RtfHeaderFooter.java
===================================================================
--- src/core/com/lowagie/text/rtf/RtfHeaderFooter.java	(revision 0)
+++ src/core/com/lowagie/text/rtf/RtfHeaderFooter.java	(revision 0)
@@ -0,0 +1,114 @@
+/**
+ * $Id$
+ *
+ * Copyright 2002 by 
+ * <a href="http://www.smb-tec.com">SMB</a> 
+ * <a href="mailto:Steffen.Stundzig@smb-tec.com">Steffen.Stundzig@smb-tec.com</a>
+ *
+ * The contents of this file are subject to the Mozilla Public License Version 1.1
+ * (the "License"); you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the License.
+ *
+ * The Original Code is 'iText, a free JAVA-PDF library'.
+ *
+ * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
+ * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
+ * All Rights Reserved.
+ * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
+ * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
+ *
+ * Contributor(s): all the names of the contributors are added in the source code
+ * where applicable.
+ *
+ * Alternatively, the contents of this file may be used under the terms of the
+ * LGPL license (the ?GNU LIBRARY GENERAL PUBLIC LICENSE?), in which case the
+ * provisions of LGPL are applicable instead of those above.  If you wish to
+ * allow use of your version of this file only under the terms of the LGPL
+ * License and not to allow others to use your version of this file under
+ * the MPL, indicate your decision by deleting the provisions above and
+ * replace them with the notice and other provisions required by the LGPL.
+ * If you do not delete the provisions above, a recipient may use your version
+ * of this file under either the MPL or the GNU LIBRARY GENERAL PUBLIC LICENSE.
+ *
+ * This library is free software; you can redistribute it and/or modify it
+ * under the terms of the MPL as stated above or under the terms of the GNU
+ * Library General Public License as published by the Free Software Foundation;
+ * either version 2 of the License, or any later version.
+ *
+ * This library is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without right the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU Library general Public License for more
+ * details.
+ *
+ * If you didn't download this code from the following link, you should check if
+ * you aren't using an obsolete version:
+ * http://www.lowagie.com/iText/
+ */
+package com.lowagie.text.rtf;
+
+import com.lowagie.text.Element;
+import com.lowagie.text.HeaderFooter;
+import com.lowagie.text.Phrase;
+
+
+/**
+ * This HeaderFooter specialization extends the normal HeaderFooter impl.
+ * by the new ctor with 'Element' param.
+ * So we have the ability to add a table or some moe sophisticated stuff
+ * as header or footer content.
+ * 
+ * ONLY FOR USE WITH THE RtfWriter NOT with the RtfWriter2.
+ *
+ * This class is based on the RtfWriter-package from Mark Hall.
+ * @author <a href="mailto:Steffen.Stundzig@smb-tec.com">Steffen.Stundzig@smb-tec.com</a>
+ * @author <a href="mailto:mhall@myrealbox.com">Mark.Hall@myrealbox.com</a>
+ * @version $Revision$Date: 2009/08/28 20:31:00 $
+ * @deprecated Please move to the RtfWriter2 and associated classes. com.lowagie.text.rtf.headerfooter.RtfHeaderFooter replaces the functionality of this class.
+ */
+public class RtfHeaderFooter extends HeaderFooter {
+
+
+    private Element content = null;
+
+        
+    /**
+     * Constructs a new header
+     * @param before
+     * @param after
+     */
+    public RtfHeaderFooter( Phrase before, Phrase after ) {
+        super( before, after );    
+    }    
+
+
+    /**
+     * Constructs a new header
+     * @param before
+     * @param numbered
+     */
+    public RtfHeaderFooter( Phrase before, boolean numbered ) {
+        super( before, numbered );
+    }    
+
+
+    /**
+     * Constructs a new header
+     * @param content
+     */
+    public RtfHeaderFooter( Element content ) {
+        super(new Phrase(content.toString()), false);
+        this.content = content;
+    }    
+
+
+    /**
+     * @return the element specified in the ctor or null;
+     */
+    public Element content() {
+        return content;
+    }
+}

Property changes on: src/core/com/lowagie/text/rtf/RtfHeaderFooter.java
___________________________________________________________________
Added: svn:executable
   + *

Index: src/core/com/lowagie/text/xml/XmlToHtml.java
===================================================================
--- src/core/com/lowagie/text/xml/XmlToHtml.java	(revision 0)
+++ src/core/com/lowagie/text/xml/XmlToHtml.java	(revision 0)
@@ -0,0 +1,144 @@
+/*
+ * Copyright 2002 by Matt Benson.
+ *
+ * The contents of this file are subject to the Mozilla Public License Version 1.1
+ * (the "License"); you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the License.
+ *
+ * The Original Code is 'iText, a free JAVA-PDF library'.
+ *
+ * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
+ * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
+ * All Rights Reserved.
+ * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
+ * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
+ *
+ * Contributor(s): all the names of the contributors are added in the source code
+ * where applicable.
+ *
+ * Alternatively, the contents of this file may be used under the terms of the
+ * LGPL license (the "GNU LIBRARY GENERAL PUBLIC LICENSE"), in which case the
+ * provisions of LGPL are applicable instead of those above.  If you wish to
+ * allow use of your version of this file only under the terms of the LGPL
+ * License and not to allow others to use your version of this file under
+ * the MPL, indicate your decision by deleting the provisions above and
+ * replace them with the notice and other provisions required by the LGPL.
+ * If you do not delete the provisions above, a recipient may use your version
+ * of this file under either the MPL or the GNU LIBRARY GENERAL PUBLIC LICENSE.
+ *
+ * This library is free software; you can redistribute it and/or modify it
+ * under the terms of the MPL as stated above or under the terms of the GNU
+ * Library General Public License as published by the Free Software Foundation;
+ * either version 2 of the License, or any later version.
+ *
+ * This library is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU Library general Public License for more
+ * details.
+ *
+ * If you didn't download this code from the following link, you should check if
+ * you aren't using an obsolete version:
+ * http://www.lowagie.com/iText/
+ */
+
+package com.lowagie.text.xml;
+
+
+import java.io.OutputStream;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+
+import com.lowagie.text.Document;
+import com.lowagie.text.DocumentException;
+import com.lowagie.text.html.HtmlWriter;
+
+
+/**
+ * HTML-specific subclass of <code>XmlToXXX</code>.
+ *
+ * @version 1.0
+ * @author <a href="mailto:orangeherbert@users.sourceforge.net">Matt Benson</a>
+ */
+public class XmlToHtml
+ extends XmlToXXX
+{
+	
+/**
+ * Construct an <CODE>XmlToHtml</CODE> with the default page size.
+ */
+	public XmlToHtml()
+	{
+		super();
+	}//end default constructor
+	
+	
+/**
+ * Construct an <CODE>XmlToHtml</CODE> with the specified page size.
+ * @param pageSize   <CODE>String</CODE> page size name from
+ * <CODE>com.lowagie.text.PageSize</CODE>.
+ */
+	public XmlToHtml(String pageSize)
+	{
+		super(pageSize);
+	}//end constructor(String)
+	
+	
+/**
+ * Add a <CODE>DocWriter</CODE> for the specified <CODE>Document</CODE> and
+ * <CODE>OutputStream</CODE>.
+ * @param doc The document to which content will be added
+ * @param out The outputstream where the HTML will be sent to
+ * @throws DocumentException if document errors occur.
+ */	
+	protected final void addWriter(Document doc, OutputStream out)
+	 throws DocumentException
+	{
+		HtmlWriter.getInstance(doc, out);
+	}//end addWriter
+	
+	
+/**
+ * Main method of the <CODE>XmlToHtml</CODE> class.
+ * @param args   <CODE>String[]</CODE> of command-line arguments.
+ */
+	public static void main(String[] args)
+	{
+		int code = 0;
+		
+		if (args.length > 1)
+		{
+			try
+			{
+				XmlToHtml x;
+				if (args.length > 2)
+				{
+					x = new XmlToHtml(args[2]);
+				}//end if at least 3 args
+				else
+				{
+					x = new XmlToHtml();
+				}//end else, only 2 args
+				
+				x.parse(new FileInputStream(args[0]), new FileOutputStream(args[1]));
+			}//end try to do everything
+			catch (Exception ex)
+			{
+				code = 2;
+				ex.printStackTrace(System.err);
+			}//end catch Exception
+		}//end if at least 2 args
+		else
+		{
+			code = 1;
+			System.err.println(
+			 "Usage:  XmlToHtml [XML file in] [PDF file out] [optional page size]");
+		}//end else, not enough arguments
+		
+		System.exit(code);
+	}//end main
+	
+}//end class XmlToHtml
